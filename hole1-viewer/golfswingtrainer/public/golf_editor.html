<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Swing Girls - Editor</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a2e;
      color: #eee;
      overflow: hidden;
      height: 100vh;
    }

    .container {
      display: flex;
      height: 100vh;
    }

    /* Left Panel */
    .panel {
      width: 400px;
      min-width: 280px;
      max-width: 600px;
      background: #16213e;
      padding: 15px;
      overflow-y: auto;
      position: relative;
      flex-shrink: 0;
    }

    /* Resize Handle */
    .resize-handle {
      position: absolute;
      top: 0;
      right: 0;
      width: 6px;
      height: 100%;
      background: #333;
      cursor: ew-resize;
      transition: background 0.2s;
      z-index: 10;
    }

    .resize-handle:hover,
    .resize-handle.dragging {
      background: #4ade80;
    }

    h1 {
      font-size: 18px;
      margin-bottom: 10px;
      color: #4ade80;
      text-align: center;
    }

    /* Editor Mode Tabs */
    .editor-tabs {
      display: flex;
      margin-bottom: 15px;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #333;
    }

    .editor-tab {
      flex: 1;
      padding: 10px;
      text-align: center;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      background: #1a1a2e;
      color: #888;
      border: none;
      transition: all 0.2s;
    }

    .editor-tab:hover {
      background: #1e3a5f;
      color: #aaa;
    }

    .editor-tab.active {
      background: #4ade80;
      color: #000;
    }

    .editor-content {
      display: none;
    }

    .editor-content.active {
      display: block;
    }

    h2 {
      color: #60a5fa;
      font-size: 14px;
      margin: 15px 0 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid #333;
    }

    h3 {
      color: #94a3b8;
      font-size: 12px;
      margin: 10px 0 5px;
    }

    /* Selection Dropdowns */
    .select-group {
      margin-bottom: 10px;
    }

    .select-group label {
      display: block;
      font-size: 12px;
      color: #aaa;
      margin-bottom: 4px;
    }

    select {
      width: 100%;
      padding: 8px;
      border: 1px solid #333;
      border-radius: 5px;
      background: #1a1a2e;
      color: #eee;
      font-size: 13px;
      cursor: pointer;
    }

    select:focus {
      outline: none;
      border-color: #4ade80;
    }

    /* Model Library Grid */
    .model-library {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
      margin-top: 8px;
    }

    .model-item {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
      background: #1a1a2e;
      border: 1px solid #333;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .model-item:hover {
      border-color: #60a5fa;
      background: #1e3a5f;
    }

    .model-item.selected {
      border-color: #4ade80;
      background: #1e4620;
    }

    .model-item .model-name {
      font-size: 11px;
      color: #ccc;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .model-item.selected .model-name {
      color: #4ade80;
      font-weight: 600;
    }

    .asset-type-label {
      font-size: 10px;
      color: #60a5fa;
      margin-bottom: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Timeline */
    .timeline-section {
      background: #1a1a2e;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 15px;
    }

    .timeline-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .timeline-row label {
      width: 50px;
      font-size: 12px;
      color: #aaa;
    }

    input[type="range"] {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      background: #333;
      border-radius: 3px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 14px;
      height: 14px;
      background: #4ade80;
      border-radius: 50%;
      cursor: pointer;
    }

    .time-display {
      width: 80px;
      text-align: right;
      font-family: monospace;
      font-size: 12px;
      color: #4ade80;
    }

    /* Control Group */
    .control-group {
      margin-bottom: 10px;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .control-row label {
      width: 30px;
      font-size: 12px;
      color: #aaa;
    }

    .value-display {
      width: 65px;
      text-align: right;
      font-family: monospace;
      font-size: 11px;
      color: #4ade80;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 3px;
      padding: 2px 4px;
      outline: none;
      cursor: text;
    }

    .value-display:hover {
      border-color: #333;
      background: #1a1a2e;
    }

    .value-display:focus {
      border-color: #4ade80;
      background: #1a1a2e;
      color: #fff;
    }

    /* Fine adjustment buttons */
    .fine-adjust {
      display: flex;
      gap: 2px;
    }

    .fine-btn {
      width: 20px;
      height: 20px;
      padding: 0;
      border: 1px solid #333;
      border-radius: 3px;
      background: #1a1a2e;
      color: #888;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      flex: none;
    }

    .fine-btn:hover {
      background: #2a2a4e;
      color: #4ade80;
      border-color: #4ade80;
    }

    .fine-btn:active {
      background: #4ade80;
      color: #000;
    }

    /* Keyframes List */
    .keyframes-section {
      background: #1a1a2e;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 15px;
    }

    .keyframe-list {
      max-height: 150px;
      overflow-y: auto;
    }

    .keyframe-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      background: #16213e;
      border-radius: 4px;
      margin-bottom: 4px;
      font-size: 12px;
    }

    .keyframe-item.active {
      background: #1e3a5f;
      border: 1px solid #4ade80;
    }

    .keyframe-time {
      color: #4ade80;
      font-family: monospace;
    }

    .keyframe-actions {
      display: flex;
      gap: 4px;
    }

    .keyframe-btn {
      padding: 2px 6px;
      font-size: 10px;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }

    .keyframe-btn.edit {
      background: #60a5fa;
      color: #000;
    }

    .keyframe-btn.delete {
      background: #ef4444;
      color: #fff;
    }

    .keyframe-btn.goto {
      background: #333;
      color: #eee;
    }

    /* Buttons */
    .button-row {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
    }

    button {
      flex: 1;
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }

    button.primary {
      background: #4ade80;
      color: #000;
    }

    button.primary:hover {
      background: #22c55e;
    }

    button.secondary {
      background: #333;
      color: #eee;
    }

    button.secondary:hover {
      background: #444;
    }

    button.add {
      background: #60a5fa;
      color: #000;
    }

    button.add:hover {
      background: #3b82f6;
    }

    /* Status */
    .status {
      text-align: center;
      padding: 8px;
      border-radius: 5px;
      font-size: 11px;
      margin-top: 10px;
    }

    .status.ready {
      background: #1e3a5f;
      color: #60a5fa;
    }

    .status.saved {
      background: #14532d;
      color: #4ade80;
    }

    /* File Link Section */
    .file-link-section {
      background: #1e3a5f;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 10px;
    }

    .file-status-row {
      margin-bottom: 8px;
    }

    .file-status {
      font-size: 11px;
      color: #60a5fa;
      word-break: break-all;
      display: block;
      padding: 4px 8px;
      background: #16213e;
      border-radius: 4px;
    }

    /* 3D Canvas */
    .canvas-container {
      flex: 1;
      position: relative;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Playback Controls */
    .playback-controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(22, 33, 62, 0.95);
      padding: 15px 20px;
      border-radius: 10px;
      min-width: 500px;
    }

    .playback-timeline {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .playback-timeline input[type="range"] {
      flex: 1;
      height: 8px;
    }

    .playback-timeline .time-info {
      display: flex;
      gap: 15px;
      font-family: monospace;
      font-size: 12px;
      color: #4ade80;
      white-space: nowrap;
    }

    .playback-buttons {
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .playback-btn {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex: none;
    }

    .shortcut-hint {
      text-align: center;
      font-size: 10px;
      color: #666;
      margin-top: 5px;
    }

    .shortcut-hint kbd {
      background: #333;
      padding: 2px 5px;
      border-radius: 3px;
      font-family: monospace;
    }

    .drag-hint {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(22, 33, 62, 0.9);
      padding: 8px 15px;
      border-radius: 6px;
      font-size: 11px;
      color: #94a3b8;
    }

    .drag-hint span {
      margin: 0 10px;
    }

    .drag-hint .grip {
      color: #4ade80;
    }

    .drag-hint .head {
      color: #60a5fa;
    }

    /* Scene Tree Styles */
    .scene-tree {
      background: #1a1a2e;
      border-radius: 8px;
      padding: 10px;
      margin-bottom: 15px;
      max-height: 300px;
      overflow-y: auto;
    }

    .tree-group {
      margin-bottom: 8px;
    }

    .tree-group-header {
      display: flex;
      align-items: center;
      padding: 6px 8px;
      background: #16213e;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      font-size: 12px;
      font-weight: 600;
      color: #60a5fa;
    }

    .tree-group-header:hover {
      background: #1e3a5f;
    }

    .tree-group-header .toggle-icon {
      margin-right: 8px;
      transition: transform 0.2s;
      font-size: 10px;
    }

    .tree-group.collapsed .toggle-icon {
      transform: rotate(-90deg);
    }

    .tree-group.collapsed .tree-group-children {
      display: none;
    }

    .tree-group-children {
      margin-left: 16px;
      margin-top: 4px;
    }

    .tree-node {
      display: flex;
      align-items: center;
      padding: 5px 8px;
      margin: 2px 0;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      color: #aaa;
      transition: all 0.15s;
    }

    .tree-node:hover {
      background: #1e3a5f;
      color: #eee;
    }

    .tree-node.selected {
      background: #4ade80;
      color: #000;
    }

    .tree-node .node-icon {
      margin-right: 8px;
      font-size: 10px;
    }

    .tree-node .node-name {
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .tree-node .node-visibility {
      opacity: 0.5;
      cursor: pointer;
      padding: 2px 4px;
    }

    .tree-node .node-visibility:hover {
      opacity: 1;
    }

    .tree-node .node-visibility.hidden {
      color: #ef4444;
    }

    /* Gizmo Mode Buttons */
    .gizmo-modes {
      display: flex;
      gap: 4px;
      margin-bottom: 10px;
    }

    .gizmo-mode-btn {
      flex: 1;
      padding: 8px;
      font-size: 11px;
      background: #1a1a2e;
      border: 1px solid #333;
      color: #888;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .gizmo-mode-btn:hover {
      background: #1e3a5f;
      color: #aaa;
    }

    .gizmo-mode-btn.active {
      background: #4ade80;
      color: #000;
      border-color: #4ade80;
    }

    /* Scene File Section */
    .scene-file-section {
      background: #1e3a5f;
      border-radius: 6px;
      padding: 10px;
      margin-bottom: 10px;
    }

    .scene-file-status {
      font-size: 11px;
      color: #60a5fa;
      word-break: break-all;
      display: block;
      padding: 4px 8px;
      background: #16213e;
      border-radius: 4px;
      margin-bottom: 8px;
    }

    .scene-name-input {
      width: 100%;
      padding: 8px;
      border: 1px solid #333;
      border-radius: 5px;
      background: #1a1a2e;
      color: #eee;
      font-size: 13px;
      margin-bottom: 8px;
    }

    .scene-name-input:focus {
      outline: none;
      border-color: #4ade80;
    }

    /* Add Prop Dialog */
    .add-prop-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .add-prop-overlay.active {
      display: flex;
    }

    .add-prop-dialog {
      background: #16213e;
      border-radius: 10px;
      padding: 20px;
      width: 400px;
      max-width: 90vw;
    }

    .add-prop-dialog h3 {
      color: #4ade80;
      margin-bottom: 15px;
    }

    .add-prop-dialog input {
      width: 100%;
      padding: 8px;
      border: 1px solid #333;
      border-radius: 5px;
      background: #1a1a2e;
      color: #eee;
      font-size: 13px;
      margin-bottom: 10px;
    }

    .add-prop-dialog input:focus {
      outline: none;
      border-color: #4ade80;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Left Panel -->
    <div class="panel" id="panel">
      <div class="resize-handle" id="resizeHandle"></div>
      <h1>Swing Girls Editor</h1>

      <!-- Editor Mode Tabs -->
      <div class="editor-tabs">
        <button class="editor-tab active" id="tabScene" onclick="switchEditor('scene')">Scene</button>
        <button class="editor-tab" id="tabVideo" onclick="switchEditor('video')">Character</button>
      </div>

      <!-- Character Editor Content (Video Characters) -->
      <div class="editor-content" id="videoEditor">
        <h2>Character Settings</h2>
        <div class="select-group">
          <label>Video Source</label>
          <select id="videoUrlSelect" onchange="loadVideoSource()">
            <!-- Populated dynamically from config.json -->
          </select>
        </div>

        <h2>Visibility</h2>
        <div class="control-group">
          <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
            <input type="checkbox" id="show3DCharacter" checked onchange="updateVisibilityToggle()">
            Show 3D Character
          </label>
          <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="show2DVideo" checked onchange="updateVisibilityToggle()">
            Show 2D Video
          </label>
        </div>

        <h2>Video Pivot (Local)</h2>
        <p style="font-size: 11px; color: #888; margin-bottom: 8px;">Origin point for scale transform (0,0 = center)</p>
        <div class="control-group">
          <div class="control-row">
            <label>X</label>
            <input type="range" id="videoPivotX" min="-1" max="1" step="0.01" value="0" oninput="updateVideoSliderDisplay(this)">
            <input type="text" class="value-display" id="videoPivotXVal" value="0.00">
            <div class="fine-adjust">
              <button class="fine-btn" onclick="adjustVideoValue('videoPivotX', -0.01)">-</button>
              <button class="fine-btn" onclick="adjustVideoValue('videoPivotX', 0.01)">+</button>
            </div>
          </div>
          <div class="control-row">
            <label>Y</label>
            <input type="range" id="videoPivotY" min="-1" max="1" step="0.01" value="0" oninput="updateVideoSliderDisplay(this)">
            <input type="text" class="value-display" id="videoPivotYVal" value="0.00">
            <div class="fine-adjust">
              <button class="fine-btn" onclick="adjustVideoValue('videoPivotY', -0.01)">-</button>
              <button class="fine-btn" onclick="adjustVideoValue('videoPivotY', 0.01)">+</button>
            </div>
          </div>
        </div>

        <h2>Video Scale</h2>
        <div class="control-group">
          <div class="control-row">
            <label>S</label>
            <input type="range" id="videoScale" min="0.1" max="5" step="0.01" value="1" oninput="updateVideoSliderDisplay(this)">
            <input type="text" class="value-display" id="videoScaleVal" value="1.00">
            <div class="fine-adjust">
              <button class="fine-btn" onclick="adjustVideoValue('videoScale', -0.01)">-</button>
              <button class="fine-btn" onclick="adjustVideoValue('videoScale', 0.01)">+</button>
            </div>
          </div>
        </div>

        <h2>Chroma Key</h2>
        <div class="control-group">
          <div class="control-row">
            <label>Color</label>
            <input type="color" id="chromaKeyColor" value="#00ff00" onchange="updateChromaKey()">
            <span style="margin-left: 8px; color: #888;">Green</span>
          </div>
          <div class="control-row">
            <label>Threshold</label>
            <input type="range" id="chromaThreshold" min="0" max="1" step="0.01" value="0.4" oninput="updateChromaKey()">
            <input type="text" class="value-display" id="chromaThresholdVal" value="0.40">
          </div>
          <div class="control-row">
            <label>Smoothing</label>
            <input type="range" id="chromaSmoothing" min="0" max="0.5" step="0.01" value="0.1" oninput="updateChromaKey()">
            <input type="text" class="value-display" id="chromaSmoothingVal" value="0.10">
          </div>
        </div>

        <h2>Playback</h2>
        <div class="button-row">
          <button class="secondary" id="videoPlayPauseBtn" onclick="toggleVideoPlayback()">Play</button>
          <button class="secondary" onclick="restartVideo()">Restart</button>
        </div>

        <h2>Timing</h2>
        <p style="font-size: 11px; color: #888; margin-bottom: 8px;">Timing values for swing animation (in seconds)</p>
        <div class="control-group">
          <div class="control-row">
            <label>Backswing Top</label>
            <input type="range" id="videoBackswingTopTime" min="0" max="3" step="0.01" value="0.8" oninput="updateVideoSliderDisplay(this); saveVideoSettings();">
            <input type="text" class="value-display" id="videoBackswingTopTimeVal" value="0.80">
            <div class="fine-adjust">
              <button class="fine-btn" onclick="adjustVideoValue('videoBackswingTopTime', -0.01)">-</button>
              <button class="fine-btn" onclick="adjustVideoValue('videoBackswingTopTime', 0.01)">+</button>
            </div>
            <button class="secondary" style="margin-left: 8px; padding: 2px 6px; font-size: 10px;" onclick="setTimingFromTimeline('videoBackswingTopTime')">Set</button>
          </div>
          <div class="control-row">
            <label>Impact Time</label>
            <input type="range" id="videoImpactTime" min="0" max="3" step="0.01" value="1.0" oninput="updateVideoSliderDisplay(this); saveVideoSettings();">
            <input type="text" class="value-display" id="videoImpactTimeVal" value="1.00">
            <div class="fine-adjust">
              <button class="fine-btn" onclick="adjustVideoValue('videoImpactTime', -0.01)">-</button>
              <button class="fine-btn" onclick="adjustVideoValue('videoImpactTime', 0.01)">+</button>
            </div>
            <button class="secondary" style="margin-left: 8px; padding: 2px 6px; font-size: 10px;" onclick="setTimingFromTimeline('videoImpactTime')">Set</button>
          </div>
        </div>

        <!-- Save Button for Character Tab -->
        <div class="button-row" style="margin-top: 20px;">
          <button class="primary" onclick="saveVideoConfig()">Save Character</button>
        </div>
      </div>

      <!-- Scene Editor Content -->
      <div class="editor-content active" id="sceneEditor">
        <h2>Scene Management</h2>
        <p style="font-size: 11px; color: #888; margin-bottom: 10px;">
          Manage golf hole scene with terrain, splat, tee box, and props
        </p>

        <!-- Scene File Management -->
        <div class="scene-file-section">
          <span id="sceneFileStatus" class="scene-file-status">No scene file linked</span>
          <input type="text" class="scene-name-input" id="sceneNameInput" placeholder="Scene Name" value="Urban Golf Range">
          <div class="button-row">
            <button class="secondary" onclick="handleNewScene()">New</button>
            <button class="secondary" onclick="handleOpenScene()">Open</button>
            <button class="primary" onclick="handleSaveScene()">Save</button>
          </div>
        </div>

        <!-- Gizmo Mode Controls -->
        <h2>Transform Gizmo</h2>
        <div class="gizmo-modes">
          <button class="gizmo-mode-btn active" id="gizmoTranslate" onclick="setGizmoMode('translate')">Move</button>
          <button class="gizmo-mode-btn" id="gizmoRotate" onclick="setGizmoMode('rotate')">Rotate</button>
          <button class="gizmo-mode-btn" id="gizmoScale" onclick="setGizmoMode('scale')">Scale</button>
        </div>
        <div class="gizmo-modes">
          <button class="gizmo-mode-btn active" id="gizmoWorld" onclick="setGizmoSpace('world')">World</button>
          <button class="gizmo-mode-btn" id="gizmoLocal" onclick="setGizmoSpace('local')">Local</button>
        </div>

        <!-- Scene Tree -->
        <h2>Scene Hierarchy</h2>
        <div class="scene-tree" id="sceneTree">
          <!-- Tree will be populated by JavaScript -->
        </div>

        <!-- Visibility Control -->
        <div class="control-group" id="sceneVisibilityControl" style="display: none; margin-top: 15px;">
          <label style="display: flex; align-items: center; gap: 8px;">
            <input type="checkbox" id="sceneNodeVisible" checked onchange="updateSceneNodeVisibility()">
            Visible
          </label>
        </div>

        <!-- Selected Object Transform -->
        <h2>Transform</h2>
        <div id="sceneTransformControls">
          <p style="font-size: 11px; color: #888; text-align: center; padding: 20px 0;">
            Select an object in the tree to edit its transform
          </p>
        </div>

        <h3>Position</h3>
        <div class="control-group" id="scenePositionControls" style="display: none;">
          <div class="control-row">
            <label>X</label>
            <input type="range" id="scenePosX" min="-200" max="200" step="0.001" value="0" oninput="updateSceneSliderDisplay(this)">
            <input type="text" class="value-display" id="scenePosXVal" value="0.000" onchange="updateSceneValueFromInput(this, 'scenePosX')">
            <div class="fine-adjust">
              <button class="fine-btn" onmousedown="startSceneRepeat('scenePosX', -0.001)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">-</button>
              <button class="fine-btn" onmousedown="startSceneRepeat('scenePosX', 0.001)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">+</button>
            </div>
          </div>
          <div class="control-row">
            <label>Y</label>
            <input type="range" id="scenePosY" min="-50" max="50" step="0.001" value="0" oninput="updateSceneSliderDisplay(this)">
            <input type="text" class="value-display" id="scenePosYVal" value="0.000" onchange="updateSceneValueFromInput(this, 'scenePosY')">
            <div class="fine-adjust">
              <button class="fine-btn" onmousedown="startSceneRepeat('scenePosY', -0.001)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">-</button>
              <button class="fine-btn" onmousedown="startSceneRepeat('scenePosY', 0.001)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">+</button>
            </div>
          </div>
          <div class="control-row">
            <label>Z</label>
            <input type="range" id="scenePosZ" min="-200" max="400" step="0.001" value="0" oninput="updateSceneSliderDisplay(this)">
            <input type="text" class="value-display" id="scenePosZVal" value="0.000" onchange="updateSceneValueFromInput(this, 'scenePosZ')">
            <div class="fine-adjust">
              <button class="fine-btn" onmousedown="startSceneRepeat('scenePosZ', -0.001)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">-</button>
              <button class="fine-btn" onmousedown="startSceneRepeat('scenePosZ', 0.001)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">+</button>
            </div>
          </div>
        </div>

        <h3>Rotation (degrees)</h3>
        <div class="control-group" id="sceneRotationControls" style="display: none;">
          <div class="control-row">
            <label>X</label>
            <input type="range" id="sceneRotX" min="-180" max="180" step="0.1" value="0" oninput="updateSceneSliderDisplay(this)">
            <input type="text" class="value-display" id="sceneRotXVal" value="0.0" onchange="updateSceneValueFromInput(this, 'sceneRotX')">
            <div class="fine-adjust">
              <button class="fine-btn" onmousedown="startSceneRepeat('sceneRotX', -0.1)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">-</button>
              <button class="fine-btn" onmousedown="startSceneRepeat('sceneRotX', 0.1)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">+</button>
            </div>
          </div>
          <div class="control-row">
            <label>Y</label>
            <input type="range" id="sceneRotY" min="-180" max="180" step="0.1" value="0" oninput="updateSceneSliderDisplay(this)">
            <input type="text" class="value-display" id="sceneRotYVal" value="0.0" onchange="updateSceneValueFromInput(this, 'sceneRotY')">
            <div class="fine-adjust">
              <button class="fine-btn" onmousedown="startSceneRepeat('sceneRotY', -0.1)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">-</button>
              <button class="fine-btn" onmousedown="startSceneRepeat('sceneRotY', 0.1)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">+</button>
            </div>
          </div>
          <div class="control-row">
            <label>Z</label>
            <input type="range" id="sceneRotZ" min="-180" max="180" step="0.1" value="0" oninput="updateSceneSliderDisplay(this)">
            <input type="text" class="value-display" id="sceneRotZVal" value="0.0" onchange="updateSceneValueFromInput(this, 'sceneRotZ')">
            <div class="fine-adjust">
              <button class="fine-btn" onmousedown="startSceneRepeat('sceneRotZ', -0.1)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">-</button>
              <button class="fine-btn" onmousedown="startSceneRepeat('sceneRotZ', 0.1)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">+</button>
            </div>
          </div>
        </div>

        <h3>Scale</h3>
        <div class="control-group" id="sceneScaleControls" style="display: none;">
          <div class="control-row">
            <label>S</label>
            <input type="range" id="sceneScale" min="0.01" max="100" step="0.001" value="1" oninput="updateSceneSliderDisplay(this)">
            <input type="text" class="value-display" id="sceneScaleVal" value="1.000" onchange="updateSceneValueFromInput(this, 'sceneScale')">
            <div class="fine-adjust">
              <button class="fine-btn" onmousedown="startSceneRepeat('sceneScale', -0.001)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">-</button>
              <button class="fine-btn" onmousedown="startSceneRepeat('sceneScale', 0.001)" onmouseup="stopSceneRepeat()" onmouseleave="stopSceneRepeat()">+</button>
            </div>
          </div>
        </div>

        <!-- File section for Terrain/Splat -->
        <div id="sceneFileControl" style="display: none; margin-top: 15px;">
          <h3>File</h3>
          <div class="control-group">
            <div style="display: flex; gap: 6px; margin-bottom: 8px;">
              <input type="text" id="sceneNodeUrl" readonly style="flex: 1; font-size: 11px; padding: 4px 6px; background: #333; border: 1px solid #555; color: #aaa; border-radius: 3px;" placeholder="No file selected">
              <button class="secondary" onclick="browseSceneNodeFile()" style="padding: 4px 8px; font-size: 11px;">Browse</button>
              <button class="secondary" onclick="clearSceneNodeFile()" style="padding: 4px 8px; font-size: 11px;">Clear</button>
            </div>
          </div>
        </div>

        <!-- Asset selector for Terrain/Splat/Mesh -->
        <div id="sceneModelSelector" style="display: none; margin-top: 15px;">
          <h3>Asset Library</h3>
          <p style="font-size: 10px; color: #888; margin-bottom: 8px;">Select an asset from the library</p>
          <div class="model-library" id="modelLibraryGrid">
            <!-- Asset items will be populated by JavaScript -->
          </div>
        </div>
      </div>

      <!-- Add Prop Dialog -->
      <div class="add-prop-overlay" id="addPropOverlay">
        <div class="add-prop-dialog">
          <h3>Add New Prop</h3>
          <input type="text" id="newPropName" placeholder="Prop Name (optional)">
          <p style="font-size: 10px; color: #888; margin: 8px 0 4px;">Select a mesh:</p>
          <div class="model-library" id="propMeshGrid" style="max-height: 200px; overflow-y: auto;">
            <!-- Mesh items will be populated by JavaScript -->
          </div>
          <input type="hidden" id="selectedPropUrl" value="">
          <div class="button-row">
            <button class="secondary" onclick="hideAddPropDialog()">Cancel</button>
            <button class="primary" onclick="addNewProp()">Add Prop</button>
          </div>
        </div>
      </div>

      <!-- File Link Section -->
      <div class="section-header" style="margin-top: 15px;">Config File</div>
      <div class="file-link-section">
        <div class="file-status-row">
          <span id="fileStatus" class="file-status">No file linked</span>
        </div>
        <div class="button-row">
          <button class="secondary" id="linkFileBtn" onclick="handleLinkFile()">Link File</button>
          <button class="secondary" id="unlinkFileBtn" onclick="handleUnlinkFile()" style="display: none;">Unlink</button>
          <button class="secondary" onclick="handleLoadFromFile()">Load</button>
        </div>
      </div>

      <!-- Shared Actions -->
      <div class="button-row">
        <button class="secondary" onclick="resetToDefault()">Reset</button>
        <button class="primary" onclick="saveConfig()">Save</button>
      </div>
      <div class="button-row">
        <button class="secondary" onclick="exportConfig()">Export JSON</button>
        <button class="secondary" onclick="importConfig()">Import JSON</button>
      </div>

      <input type="file" id="fileInput" accept=".json" style="display: none" onchange="handleFileImport(event)">

      <div class="status ready" id="status">Ready - Changes broadcast in real-time</div>
    </div>

    <!-- 3D Canvas -->
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
      <div class="drag-hint">
        <span class="grip">&#9679; Grip</span> Drag to move position |
        <span class="head">&#9679; Head</span> Drag to rotate
      </div>
      <div class="playback-controls">
        <div class="playback-timeline">
          <input type="range" id="timelineSlider" min="0" max="1" step="0.001" value="0">
          <div class="time-info">
            <span id="timeDisplay">0.000s</span>
            <span id="frameDisplay">0 / 0</span>
          </div>
        </div>
        <div class="playback-buttons">
          <button class="playback-btn secondary" onclick="skipToStart()" title="Skip to Start (Home)">|&lt;</button>
          <button class="playback-btn secondary" onclick="stepBack()" title="Step Back (Left Arrow)">&lt;</button>
          <button class="playback-btn primary" id="playPauseBtn" onclick="togglePlay()" title="Play/Pause (Space)">></button>
          <button class="playback-btn secondary" onclick="stepForward()" title="Step Forward (Right Arrow)">&gt;</button>
          <button class="playback-btn secondary" onclick="skipToEnd()" title="Skip to End (End)">&gt;|</button>
        </div>
        <div class="shortcut-hint">
          <kbd>Space</kbd> Play/Pause | <kbd>Left</kbd>/<kbd>Right</kbd> Frame | <kbd>Home</kbd>/<kbd>End</kbd> Skip | <kbd>Ctrl+Z</kbd> Undo
        </div>
      </div>
    </div>
  </div>

  <!-- Three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.170.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.170.0/examples/jsm/",
        "@sparkjsdev/spark": "https://cdn.jsdelivr.net/npm/@sparkjsdev/spark@0.1.10/dist/spark.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';

    // Make THREE available globally for armIK.js
    window.THREE = THREE;
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';
    import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
    import { SplatMesh } from '@sparkjsdev/spark';
    import {
      terrainVertexPars,
      terrainVertexMain,
      terrainFragmentPars,
      terrainFragmentMain
    } from '../src/shaders/terrainShaders.ts';

    // Constants
    const CHANNEL_NAME = 'swing-girls-motion-config';
    const STORAGE_KEY = 'swing-girls-motion-config';
    const FILE_HANDLE_DB_NAME = 'swing-girls-editor';
    const FILE_HANDLE_STORE_NAME = 'fileHandles';
    const FILE_HANDLE_KEY = 'configFileHandle';
    const DEG_TO_RAD = Math.PI / 180;
    const RAD_TO_DEG = 180 / Math.PI;
    const FPS = 30;

    // Character and animation paths
    const CHARACTER_PATHS = {
      kai: '/models/characters/Kai.glb',
      malia: '/models/characters/Malia.glb',
      zara: '/models/characters/Zara.glb',
    };

    // Video characters - populated from config.json
    // Structure: { "charId:videoType": { charId, videoType, url } }
    let VIDEO_CHARACTERS = {};

    function isVideoCharacter(charId) {
      // Check if this character has video config (at least driver video)
      return config?.characters?.[charId]?.video?.driver != null;
    }

    /**
     * Populate VIDEO_CHARACTERS from config.characters.{charId}.video.{videoType}
     * Extracts non-idle video entries (driver, iron, etc.)
     */
    function populateVideoCharactersFromConfig() {
      VIDEO_CHARACTERS = {};
      if (config?.characters) {
        for (const [charId, charConfig] of Object.entries(config.characters)) {
          if (charConfig?.video) {
            for (const [videoType, videoConfig] of Object.entries(charConfig.video)) {
              // Skip idle videos - they're for selection screen
              if (videoType !== 'idle' && videoConfig?.url) {
                const key = `${charId}:${videoType}`;
                VIDEO_CHARACTERS[key] = {
                  charId,
                  videoType,
                  url: videoConfig.url,
                };
              }
            }
          }
        }
      }
      // Update dropdown
      updateVideoSourceDropdown();
    }

    /**
     * Update the video source dropdown from VIDEO_CHARACTERS
     */
    function updateVideoSourceDropdown() {
      const select = document.getElementById('videoUrlSelect');
      if (!select) return;

      // Clear existing options
      select.innerHTML = '';

      // Add options from VIDEO_CHARACTERS
      for (const [key, { charId, videoType, url }] of Object.entries(VIDEO_CHARACTERS)) {
        const option = document.createElement('option');
        option.value = key; // Use "charId:videoType" as value
        // Display as "CharacterName - VideoType"
        const displayName = charId.charAt(0).toUpperCase() + charId.slice(1);
        option.textContent = `${displayName} - ${videoType}`;
        select.appendChild(option);
      }

      // Select first option if available
      if (select.options.length > 0) {
        select.selectedIndex = 0;
      }
    }

    // ===== File System Access API helpers =====
    let configFileHandle = null;
    let configFilePath = null; // Display name for UI

    // IndexedDB helpers for storing FileSystemFileHandle
    function openFileHandleDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(FILE_HANDLE_DB_NAME, 1);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(FILE_HANDLE_STORE_NAME)) {
            db.createObjectStore(FILE_HANDLE_STORE_NAME);
          }
        };
      });
    }

    async function saveFileHandle(handle, fileName) {
      const db = await openFileHandleDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(FILE_HANDLE_STORE_NAME, 'readwrite');
        const store = tx.objectStore(FILE_HANDLE_STORE_NAME);
        store.put({ handle, fileName }, FILE_HANDLE_KEY);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function loadFileHandle() {
      const db = await openFileHandleDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(FILE_HANDLE_STORE_NAME, 'readonly');
        const store = tx.objectStore(FILE_HANDLE_STORE_NAME);
        const request = store.get(FILE_HANDLE_KEY);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function clearFileHandle() {
      const db = await openFileHandleDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(FILE_HANDLE_STORE_NAME, 'readwrite');
        const store = tx.objectStore(FILE_HANDLE_STORE_NAME);
        store.delete(FILE_HANDLE_KEY);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // Request permission to access the file
    async function verifyFilePermission(handle, mode = 'readwrite') {
      const options = { mode };
      if (await handle.queryPermission(options) === 'granted') {
        return true;
      }
      if (await handle.requestPermission(options) === 'granted') {
        return true;
      }
      return false;
    }

    // Try to restore file handle from IndexedDB
    // Only queries permission (no request) since user activation is required for requestPermission
    async function tryRestoreFileHandle() {
      try {
        const stored = await loadFileHandle();
        if (stored?.handle) {
          // Only query, don't request - requestPermission requires user activation
          const permission = await stored.handle.queryPermission({ mode: 'readwrite' });
          if (permission === 'granted') {
            configFileHandle = stored.handle;
            configFilePath = stored.fileName;
            updateFileStatusUI();
            return true;
          }
          // Permission not granted - store handle for later re-request on user action
          configFileHandle = stored.handle;
          configFilePath = stored.fileName;
          updateFileStatusUI();
        }
      } catch (e) {
        console.warn('Failed to restore file handle:', e);
      }
      return false;
    }

    // Select a config file using File System Access API
    async function selectConfigFile() {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'JSON Config',
            accept: { 'application/json': ['.json'] }
          }],
          multiple: false
        });

        configFileHandle = handle;
        configFilePath = handle.name;
        await saveFileHandle(handle, handle.name);
        updateFileStatusUI();
        return true;
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.error('Failed to select file:', e);
          showStatus('Failed to select file', 'ready');
        }
        return false;
      }
    }

    // Read config from the linked file
    async function readConfigFromFile() {
      if (!configFileHandle) return null;

      try {
        const hasPermission = await verifyFilePermission(configFileHandle, 'read');
        if (!hasPermission) {
          throw new Error('Permission denied');
        }

        const file = await configFileHandle.getFile();
        const text = await file.text();
        const data = JSON.parse(text);

        if (data?.defaults && data?.characters) {
          return data;
        }
        throw new Error('Invalid config format');
      } catch (e) {
        console.warn('Failed to read config from file:', e);
        configFileHandle = null;
        configFilePath = null;
        await clearFileHandle();
        updateFileStatusUI();
        return null;
      }
    }

    // Write config to the linked file
    async function writeConfigToFile() {
      if (!configFileHandle) {
        showStatus('No file linked. Click "Link File" first.', 'ready');
        return false;
      }

      try {
        const hasPermission = await verifyFilePermission(configFileHandle);
        if (!hasPermission) {
          throw new Error('Permission denied');
        }

        const writable = await configFileHandle.createWritable();
        const json = JSON.stringify(config, null, 2);
        await writable.write(json);
        await writable.close();
        return true;
      } catch (e) {
        console.error('Failed to write config to file:', e);
        showStatus('Failed to save to file: ' + e.message, 'ready');
        return false;
      }
    }

    // Unlink the current file
    async function unlinkConfigFile() {
      configFileHandle = null;
      configFilePath = null;
      await clearFileHandle();
      updateFileStatusUI();
      showStatus('File unlinked', 'ready');
    }

    // Update UI to show linked file status
    function updateFileStatusUI() {
      const fileStatus = document.getElementById('fileStatus');
      const linkBtn = document.getElementById('linkFileBtn');
      const unlinkBtn = document.getElementById('unlinkFileBtn');

      if (configFileHandle && configFilePath) {
        fileStatus.textContent = configFilePath;
        fileStatus.title = configFilePath;
        linkBtn.textContent = 'Change File';
        unlinkBtn.style.display = 'inline-block';
      } else {
        fileStatus.textContent = 'No file linked';
        fileStatus.title = '';
        linkBtn.textContent = 'Link File';
        unlinkBtn.style.display = 'none';
      }
    }
    // ===== End File System Access API helpers =====

    const ANIMATION_PATHS = {
      golf_drive: '/animations/Golf_Drive.fbx',
      golf_drive1: '/animations/Golf_Drive1.fbx',
      golf_drive2: '/animations/Golf_Drive2.fbx',
      golf_drive3: '/animations/Golf_Drive3.fbx',
      golf_drive4: '/animations/Golf_Drive4.fbx',
      golf_drive5: '/animations/Golf_Drive5.fbx',
      idle: '/animations/Idle.fbx',
    };

    const CLUB_MODEL_PATHS = {
      driver: '/models/clubs/driver.glb',
      ironclub3: '/models/clubs/ironclub3.fbx',
      ironclub4: '/models/clubs/ironclub4.fbx',
      ironclub5: '/models/clubs/ironclub5.fbx',
    };

    // Asset Library - available assets for scene objects organized by type
    // Types: terrain (.terrain), splat (.ply/.splat), mesh (.glb/.fbx)
    // URLs use relative paths (./...) to match scene file format
    const ASSET_LIBRARY = {
      // Terrain files (.terrain)
      terrain: [
        { id: 'terrain-default', name: 'Golf Terrain', url: './terrains/terrain.terrain', icon: '[#]' },
      ],
      // Gaussian splat files (.ply, .splat)
      splat: [
        { id: 'splat-urban', name: 'Urban Golf Range', url: './splats/Urban-Golf-Range.ply', icon: '[*]' },
      ],
      // 3D mesh files (.glb, .fbx) - for teeBox and props
      mesh: [
        { id: 'teebox-standard', name: 'Teebox', url: './models/teebox/Teebox.glb', icon: '[T]' },
        { id: 'teebox-green', name: 'Teebox Green', url: './models/teebox/Teebox_green.glb', icon: '[G]' },
        // Future props can be added here
        // { id: 'flag', name: 'Golf Flag', url: './models/props/flag.glb', icon: '[F]' },
      ],
    };

    // Map node types to asset library categories
    const NODE_TYPE_TO_ASSET_TYPE = {
      terrain: 'terrain',
      splat: 'splat',
      teeBox: 'mesh',
      prop: 'mesh',
    };

    // Pre-load assets for faster selection
    const preloadedAssets = new Map();

    async function preloadAssetLibrary() {
      const gltfLoader = new GLTFLoader();

      // Pre-load mesh files (GLB/FBX)
      for (const asset of ASSET_LIBRARY.mesh) {
        try {
          gltfLoader.load(asset.url, (gltf) => {
            preloadedAssets.set(asset.url, gltf);
            console.log('[AssetLibrary] Preloaded mesh:', asset.name);
          }, undefined, (error) => {
            console.warn('[AssetLibrary] Failed to preload mesh:', asset.name, error);
          });
        } catch (e) {
          console.warn('[AssetLibrary] Error preloading mesh:', asset.name, e);
        }
      }

      // Pre-fetch terrain files (JSON) for metadata
      for (const asset of ASSET_LIBRARY.terrain) {
        try {
          fetch(asset.url)
            .then(res => res.ok ? res.json() : null)
            .then(data => {
              if (data) {
                preloadedAssets.set(asset.url, data);
                console.log('[AssetLibrary] Preloaded terrain:', asset.name);
              }
            })
            .catch(() => console.warn('[AssetLibrary] Failed to preload terrain:', asset.name));
        } catch (e) {
          console.warn('[AssetLibrary] Error preloading terrain:', asset.name, e);
        }
      }

      // Splat files are too large to preload - just log availability
      for (const asset of ASSET_LIBRARY.splat) {
        console.log('[AssetLibrary] Splat available:', asset.name, asset.url);
      }
    }

    // Default club config (for character attachment)
    const DEFAULT_CLUB = {
      position: { x: 0, y: 0.05, z: 0 },
      rotation: { x: -Math.PI / 2, y: -Math.PI / 2, z: -Math.PI / 2 },
      scale: 1,
    };

    // Default club model config (for model itself)
    const DEFAULT_CLUB_MODEL = {
      pivot: { x: 0, y: 0, z: 0 },
      scale: 1,
      rotation: { x: 0, y: 0, z: 0 },
    };

    // Default config - rotation in radians to match game
    const DEFAULT_CONFIG = {
      clubs: {
        driver: { ...DEFAULT_CLUB_MODEL },
        ironclub3: { ...DEFAULT_CLUB_MODEL },
        ironclub4: { ...DEFAULT_CLUB_MODEL },
        ironclub5: { ...DEFAULT_CLUB_MODEL },
      },
      defaults: {
        club: { ...DEFAULT_CLUB },
        ball: {
          position: { x: -0.5, y: 0.02, z: 0.3 },
        },
        selectionCamera: {
          position: { x: 0.0789, y: 1.9303, z: -2.8023 },
          target: { x: -0.0560, y: 1.5018, z: 0.1801 },
        },
        playCamera: {
          position: { x: 0.6032, y: 1.7462, z: -2.9766 },
          target: { x: 0.5719, y: 1.3670, z: -0.1377 },
        },
      },
      characters: {
        kai: {
          club: { ...DEFAULT_CLUB },
          golf_drive: { keyframes: [] },
          golf_drive1: { keyframes: [] },
          golf_drive2: { keyframes: [] },
          golf_drive3: { keyframes: [] },
          golf_drive4: { keyframes: [] },
          golf_drive5: { keyframes: [] },
          idle: { keyframes: [] },
        },
        malia: {
          club: { ...DEFAULT_CLUB },
          golf_drive: { keyframes: [] },
          golf_drive1: { keyframes: [] },
          golf_drive2: { keyframes: [] },
          golf_drive3: { keyframes: [] },
          golf_drive4: { keyframes: [] },
          golf_drive5: { keyframes: [] },
          idle: { keyframes: [] },
        },
        zara: {
          club: { ...DEFAULT_CLUB },
          golf_drive: { keyframes: [] },
          golf_drive1: { keyframes: [] },
          golf_drive2: { keyframes: [] },
          golf_drive3: { keyframes: [] },
          golf_drive4: { keyframes: [] },
          golf_drive5: { keyframes: [] },
          idle: { keyframes: [] },
        },
        // Video characters with nested video config
        ksenia: {
          video: {
            driver: {
              url: './videos/Ksenia_driver.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: 0 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
            idle: {
              url: './videos/Ksenia_idle.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
            iron: {
              url: './videos/Ksenia_iron.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
          },
        },
        sandra: {
          video: {
            driver: {
              url: './videos/Sandra_driver.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
            idle: {
              url: './videos/Sandra_idle.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
            iron: {
              url: './videos/Sandra_iron.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
          },
        },
        arin: {
          video: {
            driver: {
              url: './videos/Arin_driver.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
            idle: {
              url: './videos/Arin_idle.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
          },
        },
        karin: {
          video: {
            driver: {
              url: './videos/Karin_driver.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
            idle: {
              url: './videos/Karin_idle.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
          },
        },
        lyn: {
          video: {
            driver: {
              url: './videos/Lyn_driver.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
            idle: {
              url: './videos/Lyn_idle.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
          },
        },
        maya: {
          video: {
            driver: {
              url: './videos/Maya_driver.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
            idle: {
              url: './videos/Maya_idle.mp4',
              offset: { x: 0, y: 0, z: 0 },
              pivot: { x: 0, y: -1 },
              scale: 1,
              chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
            },
          },
        },
      },
      terrain: {
        url: '/terrains/terrain.terrain',
        position: { x: 0, y: 0, z: 100 },
        visible: true,
      },
    };

    // State
    let config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
    let editorMode = 'scene'; // 'scene', 'motion', 'club', 'video', 'terrain', 'splat'
    let currentCharacter = 'kai';
    let currentAnimation = 'golf_drive';
    let currentClubModel = 'ironclub5'; // For club editor
    let currentMotionClub = 'ironclub5'; // For golf editor (club attached to hand)
    let currentVideoCharacter = 'ksenia'; // For video editor
    let currentVideoType = 'driver'; // For video editor (driver, iron, idle, etc.)
    let currentTime = 0;
    let animationDuration = 1;
    let isPlaying = false;
    let isCurrentCharacterGLB = false; // Track if current character is GLB format

    // Three.js
    let scene, camera, renderer, controls;
    let character, mixer, animationAction;
    let club, ball, tee, handBone;
    let clubShaft, clubHead; // Separate references for raycasting
    let handAxes; // Axes helper for right hand coordinate system
    let terrainMesh = null; // Terrain mesh
    let terrainData = null; // Loaded terrain data (heightData, splatData, dimensions)
    let terrainUniforms = null; // Shader uniforms for terrain (for real-time updates)
    let splatMesh = null; // Gaussian splat mesh

    let clock;

    // Club editor mode - standalone club view
    let standaloneClub; // Club model for club editor mode
    let clubPivotHelper; // Visual helper for pivot point

    // Video billboard
    let videoBillboard; // Plane mesh with video texture
    let videoBillboardGroup; // Parent group for pivot-based transforms
    let videoElement; // HTML video element
    let videoTexture; // Three.js video texture
    let videoPositionMarker; // Visual marker for video position
    let videoPivotMarker; // Visual marker for pivot point on video

    // Drag state
    let raycaster, mouse;
    let isDragging = false;
    let dragTarget = null; // 'shaft' or 'head'
    let dragPlane;
    let dragStartPoint = new THREE.Vector3();
    let dragStartClubPos = new THREE.Vector3();
    let dragStartClubRot = new THREE.Euler();

    // BroadcastChannel
    const channel = new BroadcastChannel(CHANNEL_NAME);

    // Undo history
    const undoHistory = [];
    const MAX_UNDO_HISTORY = 50;
    let lastSavedState = null;

    // Save current state to undo history
    function saveUndoState() {
      const state = {
        config: JSON.parse(JSON.stringify(config)),
        sliders: {
          clubPosX: document.getElementById('clubPosX')?.value,
          clubPosY: document.getElementById('clubPosY')?.value,
          clubPosZ: document.getElementById('clubPosZ')?.value,
          clubRotX: document.getElementById('clubRotX')?.value,
          clubRotY: document.getElementById('clubRotY')?.value,
          clubRotZ: document.getElementById('clubRotZ')?.value,
          clubScale: document.getElementById('clubScale')?.value,
          charPosX: document.getElementById('charPosX')?.value,
          charPosY: document.getElementById('charPosY')?.value,
          charPosZ: document.getElementById('charPosZ')?.value,
          ballPosX: document.getElementById('ballPosX')?.value,
          ballPosY: document.getElementById('ballPosY')?.value,
          ballPosZ: document.getElementById('ballPosZ')?.value,
          impactTime: document.getElementById('impactTime')?.value,
          modelPivotX: document.getElementById('modelPivotX')?.value,
          modelPivotY: document.getElementById('modelPivotY')?.value,
          modelPivotZ: document.getElementById('modelPivotZ')?.value,
          modelRotX: document.getElementById('modelRotX')?.value,
          modelRotY: document.getElementById('modelRotY')?.value,
          modelRotZ: document.getElementById('modelRotZ')?.value,
          modelScale: document.getElementById('modelScale')?.value,
        },
        editorMode,
        currentCharacter,
        currentAnimation,
        currentClubModel,
      };

      // Only save if state actually changed
      const stateStr = JSON.stringify(state);
      if (stateStr !== lastSavedState) {
        undoHistory.push(state);
        if (undoHistory.length > MAX_UNDO_HISTORY) {
          undoHistory.shift();
        }
        lastSavedState = stateStr;
      }
    }

    // Restore state from undo history
    function undo() {
      if (undoHistory.length < 2) {
        showStatus('Nothing to undo', 'ready');
        return;
      }

      // Pop current state
      undoHistory.pop();
      // Get previous state
      const state = undoHistory[undoHistory.length - 1];
      if (!state) return;

      // Restore config
      config = JSON.parse(JSON.stringify(state.config));

      // Restore sliders
      Object.entries(state.sliders).forEach(([id, value]) => {
        const slider = document.getElementById(id);
        if (slider && value !== undefined) {
          slider.value = value;
        }
      });

      // Update displays and 3D view
      updateAllDisplays();
      updateClubModelDisplays();
      updateClubTransform();
      updateCharacterPosition();
      updateBallPosition();
      updateStandaloneClubTransform();
      updateGolfEditorClubModel();
      updateKeyframeList();
      broadcastConfig();

      lastSavedState = JSON.stringify(state);
      showStatus('Undo', 'saved');
    }

    // ==================== TERRAIN LOADING ====================
    // Terrain shaders imported from ../src/shaders/terrainShaders.ts

    // Decode Base64 to Float32Array (heightmap)
    function base64ToHeightData(base64) {
      const binary = atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new Float32Array(bytes.buffer);
    }

    // Decode Base64 to Uint8Array (splatmap)
    function base64ToSplatData(base64) {
      const binary = atob(base64);
      const data = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        data[i] = binary.charCodeAt(i);
      }
      return data;
    }

    // Get heightmap grid size
    function getHeightmapSize(dimensions) {
      const { width, depth, resolution } = dimensions;
      return {
        cols: Math.floor(width * resolution) + 1,
        rows: Math.floor(depth * resolution) + 1,
      };
    }

    // Create heightmap DataTexture
    function createHeightMapTexture(heightData, dimensions) {
      const { cols, rows } = getHeightmapSize(dimensions);
      const texture = new THREE.DataTexture(
        heightData,
        cols,
        rows,
        THREE.RedFormat,
        THREE.FloatType
      );
      texture.needsUpdate = true;
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      return texture;
    }

    // Create splatmap DataTexture
    function createSplatMapTexture(splatData, dimensions) {
      const { cols, rows } = getHeightmapSize(dimensions);
      const texture = new THREE.DataTexture(
        splatData,
        cols,
        rows,
        THREE.RGBAFormat,
        THREE.UnsignedByteType
      );
      texture.needsUpdate = true;
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      return texture;
    }

    // Load terrain from URL
    async function loadTerrain() {
      // Use sceneConfig.terrain if available, otherwise fall back to defaults
      const terrainConfig = sceneConfig?.terrain || {
        url: '/terrains/terrain.terrain',
        position: { x: 0, y: 0, z: 100 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: 1,
        visible: true,
      };

      if (!terrainConfig.visible) {
        console.log('Terrain visibility disabled');
        return;
      }

      if (!terrainConfig.url) {
        console.log('No terrain URL configured');
        return;
      }

      try {
        // Load terrain file
        const response = await fetch(terrainConfig.url);
        if (!response.ok) throw new Error('Failed to load terrain file');
        const fileData = await response.json();

        // Extract data (heightScale from file, default 20)
        const dimensions = fileData.dimensions;
        const heightScale = fileData.heightScale ?? 20;
        const heightData = base64ToHeightData(fileData.data.heightmap);
        const splatData = base64ToSplatData(fileData.data.splatmap);
        const tileScale = fileData.textures?.tileScale || 10;
        const layers = fileData.textures?.layers || [];

        terrainData = { dimensions, heightData, splatData, heightScale, tileScale, layers };

        // Load textures
        const textureLoader = new THREE.TextureLoader();
        const defaultTextures = [
          '/textures/grass/fairway.png',
          '/textures/grass/rough.png',
          '/textures/grass/green.png',
          '/textures/sand/beach_color.jpg',
        ];

        // Resolve texture paths relative to terrain file directory
        const terrainDir = terrainConfig.url.substring(0, terrainConfig.url.lastIndexOf('/') + 1);
        const resolveTexturePath = (path) => {
          if (!path) return null;
          if (path.startsWith('/') || path.startsWith('http')) return path;
          if (path.startsWith('./')) return terrainDir + path.substring(2);
          if (path.startsWith('../')) {
            // Handle parent directory references
            const parts = terrainDir.split('/').filter(p => p);
            const pathParts = path.split('/');
            let upCount = 0;
            for (const p of pathParts) {
              if (p === '..') upCount++;
              else break;
            }
            const baseParts = parts.slice(0, -upCount);
            const restParts = pathParts.slice(upCount);
            return '/' + baseParts.concat(restParts).join('/');
          }
          return terrainDir + path;
        };

        const texturePaths = layers.length >= 4
          ? layers.map(l => resolveTexturePath(l.colorMap))
          : defaultTextures;

        // Helper to load texture with wrapping
        const loadTexture = (path) => new Promise((resolve) => {
          if (!path) { resolve(null); return; }
          textureLoader.load(path, (tex) => {
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            resolve(tex);
          }, undefined, () => resolve(null));
        });

        const textures = await Promise.all(texturePaths.map(loadTexture));

        // Load detail textures
        const detailPaths = layers.map(l => resolveTexturePath(l.detail?.detailMap));
        const detailTextures = await Promise.all(detailPaths.map(loadTexture));

        // Check if any detail textures are loaded
        const useDetailMaps = detailTextures.some(t => t !== null);

        // Create data textures
        const heightMap = createHeightMapTexture(heightData, dimensions);
        const splatMap = createSplatMapTexture(splatData, dimensions);

        // Create geometry
        const { width, depth, resolution } = dimensions;
        const { cols, rows } = getHeightmapSize(dimensions);
        const geometry = new THREE.PlaneGeometry(width, depth, cols - 1, rows - 1);
        geometry.rotateX(-Math.PI / 2);

        // Create material with custom shader
        const material = new THREE.MeshStandardMaterial({
          roughness: 0.8,
          metalness: 0.0,
        });

        // Create uniforms object at module scope for real-time updates
        terrainUniforms = {
          uHeightMap: { value: heightMap },
          uHeightScale: { value: heightScale },
          uSplatMap: { value: splatMap },
          uTexture0: { value: textures[0] },
          uTexture1: { value: textures[1] },
          uTexture2: { value: textures[2] },
          uTexture3: { value: textures[3] },
          uNormal0: { value: null },
          uNormal1: { value: null },
          uNormal2: { value: null },
          uNormal3: { value: null },
          uTileScale: { value: tileScale },
          uTerrainSize: { value: new THREE.Vector2(width, depth) },
        };

        // Add detail uniforms if detail maps are used
        if (useDetailMaps) {
          for (let i = 0; i < 4; i++) {
            const layer = layers[i];
            const detail = layer?.detail;
            terrainUniforms[`uDetail${i}`] = { value: detailTextures[i] };
            terrainUniforms[`uDetailNormal${i}`] = { value: null };
            terrainUniforms[`uDetailSettings${i}`] = {
              value: detail ? new THREE.Vector4(
                detail.tileScale ?? 0.2,
                detail.strength ?? 0.5,
                detail.fadeStart ?? 20,
                detail.fadeEnd ?? 50
              ) : new THREE.Vector4(0.2, 0, 20, 50)
            };
          }
        }

        material.onBeforeCompile = (shader) => {
          // Assign pre-created uniforms to shader
          Object.assign(shader.uniforms, terrainUniforms);

          // Build shader defines
          let defines = '';
          if (useDetailMaps) {
            defines += '#define USE_DETAIL_MAPS\n';
          }

          shader.vertexShader = shader.vertexShader.replace(
            '#include <common>',
            `#include <common>\n${terrainVertexPars}`
          );
          shader.vertexShader = shader.vertexShader.replace(
            '#include <begin_vertex>',
            `#include <begin_vertex>\n${terrainVertexMain}`
          );
          shader.fragmentShader = shader.fragmentShader.replace(
            '#include <common>',
            `${defines}#include <common>\n${terrainFragmentPars}`
          );
          shader.fragmentShader = shader.fragmentShader.replace(
            '#include <map_fragment>',
            terrainFragmentMain
          );

          material.userData.shader = shader;
        };

        // Create mesh
        terrainMesh = new THREE.Mesh(geometry, material);
        terrainMesh.position.set(
          terrainConfig.position.x,
          terrainConfig.position.y,
          terrainConfig.position.z
        );
        // Apply rotation from config (degrees to radians)
        if (terrainConfig.rotation) {
          terrainMesh.rotation.set(
            (terrainConfig.rotation.x ?? 0) * DEG_TO_RAD,
            (terrainConfig.rotation.y ?? 0) * DEG_TO_RAD,
            (terrainConfig.rotation.z ?? 0) * DEG_TO_RAD
          );
        }
        // Apply scale from config
        const terrainScale = terrainConfig.scale ?? 1;
        terrainMesh.scale.set(terrainScale, terrainScale, terrainScale);
        terrainMesh.receiveShadow = true;
        terrainMesh.castShadow = true;

        scene.add(terrainMesh);
        console.log('Terrain loaded:', dimensions.width + 'x' + dimensions.depth, 'at scale:', terrainScale);

      } catch (error) {
        console.error('Failed to load terrain:', error);
      }
    }

    // Update terrain position from config
    function updateTerrainPosition() {
      if (!terrainMesh) return;
      const tc = config.terrain;
      if (tc) {
        terrainMesh.position.set(tc.position.x, tc.position.y, tc.position.z);
      }
    }

    // ==================== END TERRAIN ====================

    // Load scene config from default scene file (for terrain/splat initialization)
    const DEFAULT_SCENE_PATH = './scenes/urban-golf-range.scene.json';

    async function loadSceneConfig() {
      // Initialize scene BroadcastChannel early
      if (!sceneChannel) {
        sceneChannel = new BroadcastChannel(SCENE_CHANNEL_NAME);
      }

      try {
        const response = await fetch(DEFAULT_SCENE_PATH);
        if (response.ok) {
          const data = await response.json();
          if (data?.version && data?.terrain && data?.splat) {
            // Merge with defaults to ensure all required fields exist
            sceneConfig = {
              ...DEFAULT_SCENE_CONFIG,
              ...data,
              terrain: { ...DEFAULT_SCENE_CONFIG.terrain, ...data.terrain },
              splat: { ...DEFAULT_SCENE_CONFIG.splat, ...data.splat },
              teeBox: {
                ...DEFAULT_SCENE_CONFIG.teeBox,
                ...(data.teeBox || {}),
                tee: { ...DEFAULT_SCENE_CONFIG.teeBox.tee, ...(data.teeBox?.tee || {}) },
              },
              props: data.props || [],
            };
            console.log('[golf_editor] Loaded default scene:', sceneConfig.name);
          }
        }
      } catch (e) {
        console.warn('[golf_editor] Failed to load default scene, using defaults:', e);
      }

      // Ensure sceneConfig exists with defaults if not loaded
      if (!sceneConfig) {
        sceneConfig = JSON.parse(JSON.stringify(DEFAULT_SCENE_CONFIG));
      }
    }

    // Initialize
    async function init() {
      // Load scene config first (needed for terrain/splat)
      await loadSceneConfig();

      // Setup Three.js (includes terrain/splat loading)
      setupScene();

      // Pre-load asset library for terrain/splat/mesh selection
      preloadAssetLibrary();

      // Load motion config
      await loadConfig();

      // Load character and animation
      await loadCharacter();
      await loadAnimation();

      // Setup standalone club for club editor
      await loadStandaloneClub();

      // Setup UI
      setupUI();

      // Save initial state for undo
      saveUndoState();

      // Initialize default editor mode (scene)
      switchEditor('scene');

      // Start render loop
      animate();
    }

    function setupScene() {
      const canvas = document.getElementById('canvas');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x1a1a2e);

      // Camera
      camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
      camera.position.set(3, 2, 3);

      // Renderer
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(canvas.clientWidth, canvas.clientHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Controls
      controls = new OrbitControls(camera, canvas);
      controls.target.set(0, 1, 0);
      controls.enableZoom = false; // Disable default zoom, use custom
      controls.update();

      // Initialize TransformControls for scene editor gizmo
      initTransformControls();

      // Custom zoom: move camera toward view direction
      canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomSpeed = 0.5;
        const direction = new THREE.Vector3();
        camera.getWorldDirection(direction);

        // Move camera along view direction
        const delta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
        camera.position.addScaledVector(direction, delta);
        // Target follows hand bone (set in animate loop), no need to move here
      }, { passive: false });

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambient);

      const directional = new THREE.DirectionalLight(0xffffff, 1.5);
      directional.position.set(5, 10, 5);
      directional.castShadow = true;
      directional.shadow.mapSize.width = 2048;
      directional.shadow.mapSize.height = 2048;
      scene.add(directional);

      const hemisphere = new THREE.HemisphereLight(0xffffff, 0x88cc88, 0.5);
      scene.add(hemisphere);

      // Floor (fallback) - will be replaced by terrain if loaded
      const floorGeom = new THREE.PlaneGeometry(20, 20);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x6abf69, roughness: 0.7 });
      const floor = new THREE.Mesh(floorGeom, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      // Grid
      const grid = new THREE.GridHelper(20, 20, 0x7dd87d, 0x5cb85c);
      grid.position.y = 0.01;
      scene.add(grid);

      // Load terrain
      loadTerrain().then(() => {
        // Hide floor when terrain is loaded
        if (terrainMesh && (sceneConfig?.terrain?.visible !== false)) {
          floor.visible = false;
          grid.visible = false;
        }
      });

      // Load Gaussian splat
      loadSplat().catch(err => {
        console.warn('Failed to load splat:', err);
      });

      // Golf Tee
      const teePoints = [
        new THREE.Vector2(0.005, 0),
        new THREE.Vector2(0.008, 0.02),
        new THREE.Vector2(0.010, 0.04),
        new THREE.Vector2(0.012, 0.06),
        new THREE.Vector2(0.018, 0.07),
        new THREE.Vector2(0.025, 0.075),
        new THREE.Vector2(0.025, 0.08),
        new THREE.Vector2(0.018, 0.08),
      ];
      const teeGeom = new THREE.LatheGeometry(teePoints, 16);
      const teeMat = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.7 });
      tee = new THREE.Mesh(teeGeom, teeMat);
      tee.castShadow = true;
      tee.receiveShadow = true;
      scene.add(tee);

      // Ball (on top of tee)
      const ballGeom = new THREE.SphereGeometry(0.02, 16, 16);
      const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
      ball = new THREE.Mesh(ballGeom, ballMat);
      ball.castShadow = true;
      scene.add(ball);

      // Clock
      clock = new THREE.Clock();

      // Raycaster for drag detection
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      dragPlane = new THREE.Plane();

      // Drag event handlers
      canvas.addEventListener('mousedown', onMouseDown);
      canvas.addEventListener('mousemove', onMouseMove);
      canvas.addEventListener('mouseup', onMouseUp);
      canvas.addEventListener('mouseleave', onMouseUp);

      // Handle resize
      window.addEventListener('resize', onResize);

      // Setup panel resize
      setupPanelResize();

      // Setup video billboard
      setupVideoBillboard();
    }

    // Chroma key shader for green screen removal
    const chromaKeyVertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const chromaKeyFragmentShader = `
      uniform sampler2D videoTexture;
      uniform vec3 keyColor;
      uniform float threshold;
      uniform float smoothing;
      varying vec2 vUv;

      void main() {
        vec4 texColor = texture2D(videoTexture, vUv);

        // Calculate color distance from key color
        float diff = length(texColor.rgb - keyColor);

        // Apply threshold with smoothing
        float alpha = smoothstep(threshold - smoothing, threshold + smoothing, diff);

        // Discard fully transparent pixels for proper depth interaction
        if (alpha < 0.01) discard;

        gl_FragColor = vec4(texColor.rgb, texColor.a * alpha);
      }
    `;

    function setupVideoBillboard() {
      // Create video element
      videoElement = document.createElement('video');
      videoElement.src = './videos/Ksenia_driver.mp4';
      videoElement.loop = true;
      videoElement.muted = true;
      videoElement.playsInline = true;
      videoElement.crossOrigin = 'anonymous';

      // Sync timeline with video playback
      videoElement.addEventListener('timeupdate', () => {
        if (editorMode === 'video' && !videoElement.paused) {
          currentTime = videoElement.currentTime;
          document.getElementById('timelineSlider').value = currentTime;
          document.getElementById('timeDisplay').textContent = currentTime.toFixed(3) + 's';
          const frame = Math.floor(currentTime * FPS);
          const totalFrames = Math.floor(animationDuration * FPS);
          document.getElementById('frameDisplay').textContent = `${frame} / ${totalFrames}`;
        }
      });

      // Create video texture
      videoTexture = new THREE.VideoTexture(videoElement);
      videoTexture.minFilter = THREE.LinearFilter;
      videoTexture.magFilter = THREE.LinearFilter;
      videoTexture.format = THREE.RGBAFormat;

      // Create shader material with chroma key
      const chromaMaterial = new THREE.ShaderMaterial({
        uniforms: {
          videoTexture: { value: videoTexture },
          keyColor: { value: new THREE.Color(0x00ff00) }, // Green
          threshold: { value: 0.4 },
          smoothing: { value: 0.1 }
        },
        vertexShader: chromaKeyVertexShader,
        fragmentShader: chromaKeyFragmentShader,
        transparent: true,
        side: THREE.DoubleSide,
        depthTest: true,
        depthWrite: true
      });

      // Create billboard group (for pivot-based transforms)
      // Structure: videoBillboardGroup (position/rotation/scale) -> videoBillboard (pivot offset)
      videoBillboardGroup = new THREE.Group();
      videoBillboardGroup.position.set(0, 1, 0);
      videoBillboardGroup.visible = false; // Hidden by default
      scene.add(videoBillboardGroup);

      // Create billboard plane (child of group, offset by pivot)
      const geometry = new THREE.PlaneGeometry(1, 1);
      videoBillboard = new THREE.Mesh(geometry, chromaMaterial);
      videoBillboardGroup.add(videoBillboard);

      // Create pivot marker (small cross on video plane)
      const pivotMarkerGroup = new THREE.Group();
      const pivotCrossSize = 0.1;
      const pivotLineMat = new THREE.LineBasicMaterial({ color: 0x00ffff, depthTest: false });

      // Horizontal line
      const hLineGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-pivotCrossSize, 0, 0.01),
        new THREE.Vector3(pivotCrossSize, 0, 0.01)
      ]);
      pivotMarkerGroup.add(new THREE.Line(hLineGeom, pivotLineMat));

      // Vertical line
      const vLineGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, -pivotCrossSize, 0.01),
        new THREE.Vector3(0, pivotCrossSize, 0.01)
      ]);
      pivotMarkerGroup.add(new THREE.Line(vLineGeom, pivotLineMat));

      // Center dot
      const dotGeom = new THREE.SphereGeometry(0.02, 8, 8);
      const dotMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, depthTest: false });
      const dot = new THREE.Mesh(dotGeom, dotMat);
      dot.position.z = 0.01;
      dot.renderOrder = 999;
      pivotMarkerGroup.add(dot);

      pivotMarkerGroup.renderOrder = 999;
      videoPivotMarker = pivotMarkerGroup;
      videoBillboardGroup.add(videoPivotMarker);

      // Adjust billboard size when video metadata loads
      videoElement.addEventListener('loadedmetadata', () => {
        const aspect = videoElement.videoWidth / videoElement.videoHeight;
        const height = 2; // Base height in world units
        videoBillboard.geometry.dispose();
        videoBillboard.geometry = new THREE.PlaneGeometry(height * aspect, height);
        // Store video dimensions for pivot calculations
        videoBillboard.userData.width = height * aspect;
        videoBillboard.userData.height = height;
        console.log('Video loaded:', videoElement.videoWidth, 'x', videoElement.videoHeight);
      });

      // Load video
      videoElement.load();

      // Create position marker (axes + sphere + vertical line)
      const markerGroup = new THREE.Group();

      // Center sphere
      const sphereGeom = new THREE.SphereGeometry(0.05, 16, 16);
      const sphereMat = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.8 });
      const sphere = new THREE.Mesh(sphereGeom, sphereMat);
      markerGroup.add(sphere);

      // Axes helper
      const axes = new THREE.AxesHelper(0.3);
      markerGroup.add(axes);

      // Vertical line to ground
      const lineGeom = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, -1, 0)
      ]);
      const lineMat = new THREE.LineBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.5 });
      const verticalLine = new THREE.Line(lineGeom, lineMat);
      markerGroup.add(verticalLine);

      // Ground circle
      const circleGeom = new THREE.RingGeometry(0.08, 0.1, 32);
      const circleMat = new THREE.MeshBasicMaterial({ color: 0xff6600, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
      const groundCircle = new THREE.Mesh(circleGeom, circleMat);
      groundCircle.rotation.x = -Math.PI / 2;
      groundCircle.position.y = -1;
      markerGroup.add(groundCircle);

      videoPositionMarker = markerGroup;
      videoPositionMarker.position.set(0, 1, 0);
      videoPositionMarker.visible = false;
      scene.add(videoPositionMarker);
    }

    // Update video billboard as billboard (always face camera)
    function updateVideoBillboard() {
      // Get values from sliders
      const pivotX = parseFloat(document.getElementById('videoPivotX')?.value || 0);
      const pivotY = parseFloat(document.getElementById('videoPivotY')?.value || 0);
      const scale = parseFloat(document.getElementById('videoScale')?.value || 1);

      // Get tee world position - pivot point is exactly at tee position
      const teePos = getTeeWorldPosition();
      const posX = teePos.x;
      const posY = teePos.y;
      const posZ = teePos.z;

      // Update position marker (visible in video mode or when video character selected in motion mode)
      const showMarker = editorMode === 'video' || (editorMode === 'motion' && isVideoCharacter(currentCharacter));
      if (videoPositionMarker && showMarker) {
        videoPositionMarker.visible = true;
        videoPositionMarker.position.set(posX, posY, posZ);

        // Update vertical line length to ground
        const verticalLine = videoPositionMarker.children[2];
        if (verticalLine && verticalLine.geometry) {
          verticalLine.geometry.dispose();
          verticalLine.geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, -posY, 0)
          ]);
        }
        // Update ground circle position
        const groundCircle = videoPositionMarker.children[3];
        if (groundCircle) {
          groundCircle.position.y = -posY;
        }
      } else if (videoPositionMarker) {
        videoPositionMarker.visible = false;
      }

      // Update billboard group (pivot point stays at tee position in world space)
      if (videoBillboardGroup && videoBillboardGroup.visible) {
        // Pivot world position (tee + offset)
        const pivotWorldPos = new THREE.Vector3(posX, posY, posZ);

        // Video dimensions
        const videoWidth = videoBillboard.userData.width || 1;
        const videoHeight = videoBillboard.userData.height || 1;

        // Scaled half dimensions
        const scaledHalfWidth = (videoWidth / 2) * scale;
        const scaledHalfHeight = (videoHeight / 2) * scale;

        // Offset from pivot to video center in screen space
        // pivotX=0.5 means pivot is right of center, so center is LEFT of pivot (-offset)
        const offsetToCenterX = -pivotX * scaledHalfWidth;
        const offsetToCenterY = -pivotY * scaledHalfHeight;

        // Get camera's right and up vectors in world space
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

        // Calculate video center position in world space
        const videoCenter = pivotWorldPos.clone()
          .addScaledVector(right, offsetToCenterX)
          .addScaledVector(up, offsetToCenterY);

        // Position group at video center
        videoBillboardGroup.position.copy(videoCenter);

        // Billboard: face camera
        videoBillboardGroup.quaternion.copy(camera.quaternion);

        // Scale applied to group
        videoBillboardGroup.scale.setScalar(scale);

        // Mesh at origin (video center is at group position)
        videoBillboard.position.set(0, 0, 0);

        // Update pivot marker position (at the pivot point in world space)
        if (videoPivotMarker) {
          // Pivot marker should be at pivot world position relative to group
          // group is at videoCenter, pivot is at pivotWorldPos
          // In group's local space (after billboard rotation), we need to find the offset
          const pivotInGroupSpace = pivotWorldPos.clone().sub(videoCenter);
          // Convert world offset to local space (inverse of billboard rotation)
          const invQuat = camera.quaternion.clone().invert();
          pivotInGroupSpace.applyQuaternion(invQuat);
          // Account for group scale
          pivotInGroupSpace.divideScalar(scale);
          videoPivotMarker.position.copy(pivotInGroupSpace);
        }
      }
    }

    function setupPanelResize() {
      const panel = document.getElementById('panel');
      const handle = document.getElementById('resizeHandle');
      let isResizing = false;
      let startX = 0;
      let startWidth = 0;

      handle.addEventListener('mousedown', (e) => {
        isResizing = true;
        startX = e.clientX;
        startWidth = panel.offsetWidth;
        handle.classList.add('dragging');
        document.body.style.cursor = 'ew-resize';
        document.body.style.userSelect = 'none';
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isResizing) return;

        const delta = e.clientX - startX;
        const newWidth = Math.max(280, Math.min(600, startWidth + delta));
        panel.style.width = newWidth + 'px';

        // Update 3D canvas size
        onResize();
      });

      document.addEventListener('mouseup', () => {
        if (isResizing) {
          isResizing = false;
          handle.classList.remove('dragging');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';

          // Save panel width to localStorage
          localStorage.setItem('swing-girls-panel-width', panel.offsetWidth);
        }
      });

      // Restore saved panel width
      const savedWidth = localStorage.getItem('swing-girls-panel-width');
      if (savedWidth) {
        const width = parseInt(savedWidth, 10);
        if (width >= 280 && width <= 600) {
          panel.style.width = width + 'px';
        }
      }
    }

    function getMousePosition(event) {
      const canvas = document.getElementById('canvas');
      const rect = canvas.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    }

    function onMouseDown(event) {
      if (!club || !handBone) return;

      getMousePosition(event);
      raycaster.setFromCamera(mouse, camera);

      // Get all club parts for intersection
      const clubParts = [];
      club.traverse((child) => {
        if (child.isMesh && (child.name === 'clubShaft' || child.name === 'clubHead')) {
          clubParts.push(child);
        }
      });

      const intersects = raycaster.intersectObjects(clubParts, false);

      if (intersects.length > 0) {
        isDragging = true;
        dragTarget = intersects[0].object.name === 'clubShaft' ? 'shaft' : 'head';

        // Disable orbit controls while dragging
        controls.enabled = false;

        // Store starting values
        dragStartClubPos.copy(club.position);
        dragStartClubRot.copy(club.rotation);

        // Create drag plane perpendicular to camera
        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir);
        dragPlane.setFromNormalAndCoplanarPoint(cameraDir, intersects[0].point);
        raycaster.ray.intersectPlane(dragPlane, dragStartPoint);

        // Visual feedback
        document.body.style.cursor = dragTarget === 'shaft' ? 'move' : 'crosshair';
      }
    }

    function onMouseMove(event) {
      // Club drag controls removed with Golf Editor
    }

    function onMouseUp() {
      if (isDragging) {
        isDragging = false;
        dragTarget = null;
        controls.enabled = true;
        document.body.style.cursor = 'default';
      }
    }

    function onResize() {
      const canvas = document.getElementById('canvas');
      const container = canvas.parentElement;
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    async function loadConfig() {
      let loadedConfig = null;

      // Try to restore linked file handle from IndexedDB
      await tryRestoreFileHandle();
      updateFileStatusUI();

      // Try loading from linked file first (if available)
      if (configFileHandle) {
        try {
          const fileConfig = await readConfigFromFile();
          if (fileConfig) {
            loadedConfig = fileConfig;
            console.log('Loaded config from linked file:', configFilePath);
          }
        } catch (e) {
          console.warn('Failed to load from linked file:', e);
        }
      }

      // Try localStorage if file loading didn't work
      if (!loadedConfig) {
        try {
          const saved = localStorage.getItem(STORAGE_KEY);
          if (saved) {
            const parsed = JSON.parse(saved);
            if (parsed?.defaults && parsed?.characters) {
              loadedConfig = parsed;
            }
          }
        } catch (e) {
          console.warn('Failed to load from localStorage:', e);
        }
      }

      // Fall back to config.json
      if (!loadedConfig) {
        try {
          const res = await fetch('/config.json');
          const data = await res.json();
          if (data?.defaults && data?.characters) {
            loadedConfig = data;
          }
        } catch (e) {
          console.warn('Failed to load /config.json, using defaults');
        }
      }

      // Merge loaded config with defaults (ensure all clubs have config)
      if (loadedConfig) {
        config = loadedConfig;
        // Ensure clubs section exists and merge with defaults
        if (!config.clubs) config.clubs = {};
        Object.keys(CLUB_MODEL_PATHS).forEach(clubId => {
          if (!config.clubs[clubId]) {
            config.clubs[clubId] = { ...DEFAULT_CLUB_MODEL };
          }
        });
      }

      // Populate VIDEO_CHARACTERS from config.characters.{charId}.video
      populateVideoCharactersFromConfig();
    }

    async function loadCharacter() {
      // 3D character rendering disabled per user request
      // Function kept for compatibility but no longer loads character
    }

    // Load video character (replaces 3D character with video billboard)
    async function loadVideoCharacter() {
      // Hide 3D character
      if (character) {
        character.visible = false;
      }
      if (club) {
        club.visible = false;
      }

      // Set video character as current video character
      currentVideoCharacter = currentCharacter;
      currentVideoType = 'driver'; // Default to driver when loading character

      // Load video settings
      loadVideoSettings();

      // Show video billboard
      if (videoBillboardGroup) {
        videoBillboardGroup.visible = true;
      }

      // Load video source from new config structure
      const videoConfig = config?.characters?.[currentVideoCharacter]?.video?.[currentVideoType];
      const videoPath = videoConfig?.url || `./videos/${currentVideoCharacter}_driver.mp4`;
      if (videoElement && videoElement.src !== videoPath) {
        videoElement.src = videoPath;
        videoElement.load();
      }

      // Wait for video metadata to get duration
      if (videoElement) {
        await new Promise((resolve) => {
          if (videoElement.readyState >= 1) {
            resolve();
          } else {
            videoElement.addEventListener('loadedmetadata', resolve, { once: true });
          }
        });

        // Set animation duration to video duration
        animationDuration = videoElement.duration;
        document.getElementById('timelineSlider').max = animationDuration;

        // Reset to start
        setVideoTime(0);
      }
    }

    // Set video playback time (synced with timeline)
    function setVideoTime(time) {
      if (!videoElement) return;
      videoElement.currentTime = time;
      currentTime = time;

      // Update timeline UI
      document.getElementById('timelineSlider').value = time;
      document.getElementById('timeDisplay').textContent = time.toFixed(3) + 's';
      const frame = Math.floor(time * FPS);
      const totalFrames = Math.floor(animationDuration * FPS);
      document.getElementById('frameDisplay').textContent = `${frame} / ${totalFrames}`;
    }

    // Update UI based on character mode (3D vs Video)
    function updateCharacterModeUI() {
      const isVideo = isVideoCharacter(currentCharacter);

      // Update 3D scene visibility
      if (isVideo) {
        if (character) character.visible = false;
        if (club) club.visible = false;
        if (videoBillboardGroup) videoBillboardGroup.visible = true;
      } else {
        if (character) character.visible = true;
        if (club) club.visible = true;
        if (videoBillboardGroup) videoBillboardGroup.visible = false;
        if (videoPositionMarker) videoPositionMarker.visible = false;
      }
    }

    async function loadAnimation() {
      if (!character || !mixer) return;

      const loader = new FBXLoader();
      const path = ANIMATION_PATHS[currentAnimation];

      try {
        const animData = await loader.loadAsync(path);
        if (animData.animations.length > 0) {
          const clip = animData.animations[0];
          animationDuration = clip.duration;

          // Update timeline slider
          document.getElementById('timelineSlider').max = animationDuration;

          // Create action
          if (animationAction) {
            animationAction.stop();
          }
          animationAction = mixer.clipAction(clip);
          animationAction.setLoop(THREE.LoopOnce, 1);
          animationAction.clampWhenFinished = true;
          animationAction.setEffectiveTimeScale(1);
          animationAction.setEffectiveWeight(1);
          animationAction.play();
          animationAction.paused = true; // Pause by default until user plays

          // Set to current time
          setAnimationTime(currentTime);
          isPlaying = false;
          document.getElementById('playPauseBtn').textContent = '>';
        }
      } catch (e) {
        console.error('Failed to load animation:', e);
      }
    }

    // Create axes helper for hand bone coordinate system
    function createHandAxes() {
      const axesSize = 0.15;
      const axesGroup = new THREE.Group();

      // X axis - bright red
      const xAxisGeom = new THREE.CylinderGeometry(0.004, 0.004, axesSize, 8);
      const xAxisMat = new THREE.MeshBasicMaterial({ color: 0xff3333 });
      const xAxis = new THREE.Mesh(xAxisGeom, xAxisMat);
      xAxis.rotation.z = -Math.PI / 2;
      xAxis.position.x = axesSize / 2;
      axesGroup.add(xAxis);

      // X arrow head
      const xArrowGeom = new THREE.ConeGeometry(0.01, 0.03, 8);
      const xArrow = new THREE.Mesh(xArrowGeom, xAxisMat);
      xArrow.rotation.z = -Math.PI / 2;
      xArrow.position.x = axesSize + 0.015;
      axesGroup.add(xArrow);

      // Y axis - bright green
      const yAxisGeom = new THREE.CylinderGeometry(0.004, 0.004, axesSize, 8);
      const yAxisMat = new THREE.MeshBasicMaterial({ color: 0x33ff33 });
      const yAxis = new THREE.Mesh(yAxisGeom, yAxisMat);
      yAxis.position.y = axesSize / 2;
      axesGroup.add(yAxis);

      // Y arrow head
      const yArrowGeom = new THREE.ConeGeometry(0.01, 0.03, 8);
      const yArrow = new THREE.Mesh(yArrowGeom, yAxisMat);
      yArrow.position.y = axesSize + 0.015;
      axesGroup.add(yArrow);

      // Z axis - bright blue
      const zAxisGeom = new THREE.CylinderGeometry(0.004, 0.004, axesSize, 8);
      const zAxisMat = new THREE.MeshBasicMaterial({ color: 0x3333ff });
      const zAxis = new THREE.Mesh(zAxisGeom, zAxisMat);
      zAxis.rotation.x = Math.PI / 2;
      zAxis.position.z = axesSize / 2;
      axesGroup.add(zAxis);

      // Z arrow head
      const zArrowGeom = new THREE.ConeGeometry(0.01, 0.03, 8);
      const zArrow = new THREE.Mesh(zArrowGeom, zAxisMat);
      zArrow.rotation.x = Math.PI / 2;
      zArrow.position.z = axesSize + 0.015;
      axesGroup.add(zArrow);

      // Origin sphere (white)
      const originGeom = new THREE.SphereGeometry(0.008, 16, 16);
      const originMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const origin = new THREE.Mesh(originGeom, originMat);
      axesGroup.add(origin);

      return axesGroup;
    }

    // Reference to the club model mesh for applying club model config (Club rendering disabled)
    let clubModelMesh = null;

    async function createClub() {
      // Club rendering disabled per user request
      // Function kept for compatibility but no longer creates club mesh
    }

    // Apply club model config (pivot, rotation, scale) to a mesh (Club rendering disabled)
    function applyClubModelConfigToMesh(mesh, clubId = currentMotionClub) {
      // Club rendering disabled - function kept for compatibility
    }

    // Update club model in golf editor when settings change (Club tab removed)
    function updateGolfEditorClubModel() {
      // Club rendering removed - function kept for compatibility
    }

    // Apply current club model slider values to config (Club tab removed)
    function applyClubModelToConfig() {
      // Club Editor UI removed - function kept for compatibility
    }

    // Load standalone club for club editor mode (Club tab removed)
    async function loadStandaloneClub() {
      // Club Editor removed - no longer loading standalone club
    }

    // Update standalone club transform from club editor sliders (Club tab removed)
    function updateStandaloneClubTransform() {
      // Club Editor removed - function kept for compatibility
    }

    // Switch between scene and video (character) editor modes
    window.switchEditor = function(mode) {
      editorMode = mode;

      // Update tabs
      document.getElementById('tabVideo').classList.toggle('active', mode === 'video');
      document.getElementById('tabScene').classList.toggle('active', mode === 'scene');

      // Update content visibility
      document.getElementById('videoEditor').classList.toggle('active', mode === 'video');
      document.getElementById('sceneEditor').classList.toggle('active', mode === 'scene');

      // Update 3D view (3D character rendering disabled)
      if (mode === 'video') {
        // Video editor mode - show video billboard
        const show2D = document.getElementById('show2DVideo')?.checked ?? true;
        if (videoBillboardGroup) videoBillboardGroup.visible = show2D;
        // Move camera to see the character clearly
        camera.position.set(0, 1.5, -3);
        controls.target.set(0, 1, 0);
        document.querySelector('.playback-controls').style.display = 'flex';
        document.querySelector('.drag-hint').style.display = 'none';
        // Load video settings from config
        loadVideoSettings();
        // Pause video and reset to frame 0
        if (videoElement) {
          videoElement.pause();
          videoElement.currentTime = 0;
          document.getElementById('videoPlayPauseBtn').textContent = 'Play';
        }
        // Set timeline to video duration for scrubbing
        if (videoElement && videoElement.duration) {
          animationDuration = videoElement.duration;
          document.getElementById('timelineSlider').max = animationDuration;
          currentTime = 0;
          document.getElementById('timelineSlider').value = 0;
          setVideoTime(0);
        }
      } else if (mode === 'scene') {
        // Scene editor mode - show all scene elements
        if (videoBillboardGroup) videoBillboardGroup.visible = false;
        if (videoPositionMarker) videoPositionMarker.visible = false;
        // Move camera to see the full scene
        camera.position.set(0, 50, -50);
        controls.target.set(0, 0, 50);
        document.querySelector('.playback-controls').style.display = 'none';
        document.querySelector('.drag-hint').style.display = 'none';
        // Initialize scene editor
        initSceneEditor();
      }

      controls.update();
    };

    // Load club model settings from config to sliders (Club tab removed)
    function loadClubModelSettings() {
      // Club Editor UI removed - function kept for compatibility
    }

    // ==================== TERRAIN SETTINGS ====================

    // Reload terrain from file
    window.reloadTerrain = async function() {
      // Remove existing terrain
      if (terrainMesh) {
        scene.remove(terrainMesh);
        terrainMesh.geometry.dispose();
        terrainMesh.material.dispose();
        terrainMesh = null;
      }
      terrainData = null;
      terrainUniforms = null;

      // Load terrain with current config
      await loadTerrain();
      showStatus('Terrain reloaded', 'saved');
    };

    // ==================== END TERRAIN SETTINGS ====================

    // ==================== SPLAT SETTINGS ====================

    // Default splat config
    const DEFAULT_SPLAT_CONFIG = {
      url: '/splats/Urban-Golf-Range.ply',
      position: { x: 0, y: 0, z: 0 },
      rotation: { x: 0, y: 180, z: 180 },
      scale: 16.537,
      visible: true,
    };

    // Load Gaussian splat from file
    async function loadSplat() {
      // Use sceneConfig.splat if available, otherwise fall back to defaults
      const sc = sceneConfig?.splat || DEFAULT_SPLAT_CONFIG;

      if (!sc.visible) {
        console.log('Splat visibility disabled');
        return;
      }

      if (!sc.url) {
        console.log('No splat URL configured');
        return;
      }

      try {
        console.log('Loading splat:', sc.url);

        // Remove existing splat
        if (splatMesh) {
          scene.remove(splatMesh);
          splatMesh = null;
        }

        // Load splat mesh using Spark library
        const splat = new SplatMesh({ url: sc.url });
        splatMesh = splat;

        // Apply transform
        splatMesh.position.set(sc.position.x, sc.position.y, sc.position.z);
        splatMesh.rotation.set(
          (sc.rotation?.x ?? 0) * DEG_TO_RAD,
          (sc.rotation?.y ?? 0) * DEG_TO_RAD,
          (sc.rotation?.z ?? 0) * DEG_TO_RAD
        );
        splatMesh.scale.setScalar(sc.scale ?? 1);

        scene.add(splatMesh);
        console.log('Splat loaded:', sc.url);

      } catch (err) {
        console.error('Failed to load splat:', err);
      }
    }

    // Reload splat from file
    window.reloadSplat = async function() {
      // Remove existing splat
      if (splatMesh) {
        scene.remove(splatMesh);
        splatMesh = null;
      }

      // Load splat with current config
      await loadSplat();
      showStatus('Splat reloaded', 'saved');
    };

    // ==================== END SPLAT SETTINGS ====================

    // Update club model slider displays (Club tab removed)
    function updateClubModelDisplays() {
      // Club Editor UI removed - function kept for compatibility
    }

    // Apply club model settings to config (Club tab removed)
    window.applyClubModelSettings = function() {
      // Club Editor UI removed - function kept for compatibility
    };

    function updateClubTransform() {
      // Golf editor club transform controls were removed
      // Club transform is now handled via keyframes in config.json
    }

    const TEE_HEIGHT = 0.08; // Tee height (must match GolfTee.tsx)

    function updateBallPosition() {
      // Ball position controls were removed with Golf Editor
      // Ball is now positioned at tee location from scene config
    }

    // Get tee world position from scene config (hierarchical transform)
    function getTeeWorldPosition() {
      if (!sceneConfig) return { x: 0, y: 0, z: 0 };

      const teeBox = sceneConfig.teeBox;
      const tee = teeBox?.tee;

      // Apply parent rotation to child's relative position
      const parentRot = new THREE.Euler(
        (teeBox?.rotation?.x ?? 0) * DEG_TO_RAD,
        (teeBox?.rotation?.y ?? 0) * DEG_TO_RAD,
        (teeBox?.rotation?.z ?? 0) * DEG_TO_RAD
      );
      const teeRelPos = new THREE.Vector3(
        tee?.position?.x ?? 0,
        tee?.position?.y ?? 0,
        tee?.position?.z ?? 0
      );
      teeRelPos.applyEuler(parentRot);

      return {
        x: (teeBox?.position?.x ?? 0) + teeRelPos.x,
        y: (teeBox?.position?.y ?? 0) + teeRelPos.y,
        z: (teeBox?.position?.z ?? 0) + teeRelPos.z,
      };
    }

    function updateCharacterPosition() {
      // Get character offset from config (video characters use video config, 3D uses character config)
      const offset = getCharacterOffset();
      const offsetX = offset.x;
      const offsetY = offset.y;
      const offsetZ = offset.z;

      // Get tee world position
      const teePos = getTeeWorldPosition();

      // Calculate character world position = tee + offset
      const worldX = teePos.x + offsetX;
      const worldY = teePos.y + offsetY;
      const worldZ = teePos.z + offsetZ;

      if (isVideoCharacter(currentCharacter)) {
        // Update video plane position if exists
        if (videoPlane) {
          videoPlane.position.set(worldX, worldY, worldZ);
        }
      } else if (character) {
        // 3D character - position at tee + offset
        character.position.set(worldX, worldY, worldZ);
      }

      // Update character proxy in Scene view (if available)
      if (typeof updateCharacterProxy === 'function') {
        updateCharacterProxy();
      }
    }

    function loadCharacterConfig() {
      // Character position controls removed - position loaded from config directly
      updateCharacterPosition();
    }

    function updateCharacterConfig() {
      // Character position controls removed - use video editor for character offset
    }

    function setAnimationTime(time) {
      currentTime = Math.max(0, Math.min(time, animationDuration));

      // In Video editor mode, always control video regardless of character selection
      if (editorMode === 'video' || isVideoCharacter(currentCharacter)) {
        // Video mode - sync video time
        if (videoElement) {
          videoElement.currentTime = currentTime;
        }
      }

      // In Motion mode with 3D character, also update 3D animation
      if (editorMode === 'motion' && !isVideoCharacter(currentCharacter) && mixer && animationAction) {
        // 3D character - reset mixer time and action time, then update to apply pose
        mixer.setTime(0);
        animationAction.time = currentTime;
        mixer.update(0);
      }

      // Update UI
      document.getElementById('timelineSlider').value = currentTime;
      document.getElementById('timeDisplay').textContent = currentTime.toFixed(3) + 's';
      const frame = Math.floor(currentTime * FPS);
      const totalFrames = Math.floor(animationDuration * FPS);
      document.getElementById('frameDisplay').textContent = `${frame} / ${totalFrames}`;

      // Update club transform from interpolated keyframes (3D only, motion mode only)
      if (editorMode === 'motion' && !isVideoCharacter(currentCharacter)) {
        updateClubFromKeyframes();
      }

      // Highlight active keyframe
      updateKeyframeList();
    }

    function updateClubFromKeyframes() {
      // Golf editor club controls removed - keyframes managed via config.json
    }

    // Get club transform at time - uses character default if no keyframes
    function getClubTransformAtTime(keyframes, time) {
      const charDefault = getCharacterClubDefault();

      // No keyframes - use character's club default
      if (!keyframes || keyframes.length === 0) {
        return {
          position: { ...charDefault.position },
          rotation: { ...charDefault.rotation },
        };
      }

      // Single keyframe
      if (keyframes.length === 1) {
        return {
          position: { ...keyframes[0].position },
          rotation: { ...keyframes[0].rotation },
        };
      }

      const sorted = [...keyframes].sort((a, b) => a.time - b.time);

      // Before first keyframe
      if (time <= sorted[0].time) {
        return {
          position: { ...sorted[0].position },
          rotation: { ...sorted[0].rotation },
        };
      }

      // After last keyframe
      if (time >= sorted[sorted.length - 1].time) {
        return {
          position: { ...sorted[sorted.length - 1].position },
          rotation: { ...sorted[sorted.length - 1].rotation },
        };
      }

      // Interpolate between keyframes using Catmull-Rom spline
      for (let i = 0; i < sorted.length - 1; i++) {
        if (time >= sorted[i].time && time <= sorted[i + 1].time) {
          const duration = sorted[i + 1].time - sorted[i].time;
          const t = duration > 0 ? (time - sorted[i].time) / duration : 0;

          // Get 4 points for Catmull-Rom (p0, p1, p2, p3)
          const p0 = sorted[Math.max(0, i - 1)];
          const p1 = sorted[i];
          const p2 = sorted[i + 1];
          const p3 = sorted[Math.min(sorted.length - 1, i + 2)];

          return {
            position: {
              x: catmullRom(p0.position.x, p1.position.x, p2.position.x, p3.position.x, t),
              y: catmullRom(p0.position.y, p1.position.y, p2.position.y, p3.position.y, t),
              z: catmullRom(p0.position.z, p1.position.z, p2.position.z, p3.position.z, t),
            },
            rotation: {
              x: catmullRom(p0.rotation.x, p1.rotation.x, p2.rotation.x, p3.rotation.x, t),
              y: catmullRom(p0.rotation.y, p1.rotation.y, p2.rotation.y, p3.rotation.y, t),
              z: catmullRom(p0.rotation.z, p1.rotation.z, p2.rotation.z, p3.rotation.z, t),
            },
          };
        }
      }

      // Fallback to character default
      return {
        position: { ...charDefault.position },
        rotation: { ...charDefault.rotation },
      };
    }

    // Helper: Get character's club default (falls back to global)
    function getCharacterClubDefault() {
      const charConfig = config.characters[currentCharacter];
      if (charConfig?.club?.position && charConfig?.club?.rotation) {
        return charConfig.club;
      }
      return config.defaults.club;
    }

    function lerp(a, b, t) {
      return a + (b - a) * t;
    }

    // Catmull-Rom spline interpolation
    // Creates smooth curves that pass through all control points
    // p0, p1, p2, p3 are four consecutive values, t interpolates between p1 and p2
    function catmullRom(p0, p1, p2, p3, t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return 0.5 * (
        (2 * p1) +
        (-p0 + p2) * t +
        (2 * p0 - 5 * p1 + 4 * p2 - p3) * t2 +
        (-p0 + 3 * p1 - 3 * p2 + p3) * t3
      );
    }

    function setupUI() {
      // Timeline slider (for video editor)
      const timelineSlider = document.getElementById('timelineSlider');
      if (timelineSlider) {
        timelineSlider.addEventListener('input', (e) => {
          setAnimationTime(parseFloat(e.target.value));
        });
      }

      // Club model sliders removed (Club tab removed)

      // Club model value inputs removed (Club tab removed)

      // Club model select removed (Club tab removed)

      // Load character and ball config
      loadCharacterConfig();
      loadBallConfig();
      loadImpactConfig();
      loadBackswingTopConfig();

      // Update keyframe list
      updateKeyframeList();

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // Ignore if typing in an input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

        switch (e.code) {
          case 'Space':
            e.preventDefault();
            togglePlay();
            break;
          case 'ArrowLeft':
            e.preventDefault();
            stepBack();
            break;
          case 'ArrowRight':
            e.preventDefault();
            stepForward();
            break;
          case 'Home':
            e.preventDefault();
            skipToStart();
            break;
          case 'End':
            e.preventDefault();
            skipToEnd();
            break;
          case 'KeyZ':
            if (e.ctrlKey || e.metaKey) {
              e.preventDefault();
              undo();
            }
            break;
        }
      });
    }

    function loadBallConfig() {
      // Ball config controls removed - ball position from scene config
    }

    function updateBallConfig() {
      // Ball config controls removed
    }

    function loadImpactConfig() {
      // Impact config controls removed - use video editor for timing
    }

    function updateImpactConfig() {
      // Impact config controls removed - use video editor for timing
    }

    window.setImpactFromTimeline = function() {
      // Impact controls removed - use video editor
    };

    function loadBackswingTopConfig() {
      // Backswing config controls removed - use video editor for timing
    }

    function updateBackswingTopConfig() {
      // Backswing config controls removed - use video editor
    }

    window.setBackswingTopFromTimeline = function() {
      // Backswing controls removed - use video editor
    };

    function updateDisplay(id) {
      const slider = document.getElementById(id);
      const display = document.getElementById(id + 'Val');
      if (!slider || !display) return; // Guard against removed elements
      if (id.includes('Rot')) {
        display.value = parseFloat(slider.value).toFixed(1);
      } else {
        display.value = parseFloat(slider.value).toFixed(3);
      }
    }

    function updateAllDisplays() {
      // Only update displays for elements that exist (Club Editor sliders)
      ['modelPivotX', 'modelPivotY', 'modelPivotZ', 'modelRotX', 'modelRotY', 'modelRotZ', 'modelScale'].forEach(id => {
        if (document.getElementById(id)) updateDisplay(id);
      });
    }

    function updateKeyframeList() {
      // Keyframe list UI removed with Golf Editor
    }

    function animate() {
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      if (isPlaying) {
        if (isVideoCharacter(currentCharacter)) {
          // Video character playback - sync with video time
          if (videoElement && !videoElement.paused) {
            currentTime = videoElement.currentTime;
            if (currentTime >= animationDuration) {
              currentTime = 0;
              videoElement.currentTime = 0;
            }
            // Update UI
            document.getElementById('timelineSlider').value = currentTime;
            document.getElementById('timeDisplay').textContent = currentTime.toFixed(3) + 's';
            const frame = Math.floor(currentTime * FPS);
            const totalFrames = Math.floor(animationDuration * FPS);
            document.getElementById('frameDisplay').textContent = `${frame} / ${totalFrames}`;
          }
        } else if (mixer && animationAction) {
          // 3D character playback
          currentTime += delta;
          if (currentTime > animationDuration) {
            currentTime = 0;
          }
          // Update UI
          document.getElementById('timelineSlider').value = currentTime;
          document.getElementById('timeDisplay').textContent = currentTime.toFixed(3) + 's';
          const frame = Math.floor(currentTime * FPS);
          const totalFrames = Math.floor(animationDuration * FPS);
          document.getElementById('frameDisplay').textContent = `${frame} / ${totalFrames}`;

          // Set animation time and update
          mixer.setTime(0);
          animationAction.time = currentTime;
          mixer.update(0);

          // Update club from keyframes
          updateClubFromKeyframes();
          updateKeyframeList();
        }
      }

      // Update orbit target to hand bone position (golf editor mode only)
      if (editorMode === 'motion' && handBone) {
        const handWorldPos = new THREE.Vector3();
        handBone.getWorldPosition(handWorldPos);
        controls.target.copy(handWorldPos);
      }

      // Update video billboard (billboard effect - face camera)
      updateVideoBillboard();

      controls.update();
      renderer.render(scene, camera);
    }

    // Video editor functions
    window.adjustVideoValue = function(sliderId, delta) {
      const slider = document.getElementById(sliderId);
      if (!slider) return;
      const newVal = parseFloat(slider.value) + delta;
      const min = parseFloat(slider.min);
      const max = parseFloat(slider.max);
      slider.value = Math.max(min, Math.min(max, newVal));
      // Update display
      updateVideoSliderDisplay(slider);
    };

    // Set timing value from current timeline position
    window.setTimingFromTimeline = function(sliderId) {
      const slider = document.getElementById(sliderId);
      if (!slider) return;
      slider.value = currentTime.toFixed(2);
      updateVideoSliderDisplay(slider);
      saveVideoSettings();
    };

    window.updateVideoSliderDisplay = function(slider) {
      const displayId = slider.id + 'Val';
      const display = document.getElementById(displayId);
      if (display) {
        // Use 2 decimals for scale/pivot, 3 decimals for offset
        const decimals = (slider.id === 'videoScale' || slider.id.includes('Pivot')) ? 2 : 3;
        display.value = parseFloat(slider.value).toFixed(decimals);
      }
      // Save to config
      saveVideoSettings();
    };

    window.updateChromaKey = function() {
      if (!videoBillboard || !videoBillboard.material.uniforms) return;

      const colorInput = document.getElementById('chromaKeyColor');
      const thresholdInput = document.getElementById('chromaThreshold');
      const smoothingInput = document.getElementById('chromaSmoothing');

      if (colorInput) {
        const color = new THREE.Color(colorInput.value);
        videoBillboard.material.uniforms.keyColor.value = color;
      }
      if (thresholdInput) {
        videoBillboard.material.uniforms.threshold.value = parseFloat(thresholdInput.value);
        const display = document.getElementById('chromaThresholdVal');
        if (display) display.value = parseFloat(thresholdInput.value).toFixed(2);
      }
      if (smoothingInput) {
        videoBillboard.material.uniforms.smoothing.value = parseFloat(smoothingInput.value);
        const display = document.getElementById('chromaSmoothingVal');
        if (display) display.value = parseFloat(smoothingInput.value).toFixed(2);
      }

      // Save to config
      saveVideoSettings();
    };

    window.toggleVideoPlayback = function() {
      if (!videoElement) return;
      const btn = document.getElementById('videoPlayPauseBtn');
      if (videoElement.paused) {
        videoElement.play().catch(e => console.log('Play failed:', e));
        if (btn) btn.textContent = 'Pause';
      } else {
        videoElement.pause();
        if (btn) btn.textContent = 'Play';
      }
    };

    window.restartVideo = function() {
      if (!videoElement) return;
      videoElement.currentTime = 0;
      videoElement.play().catch(e => console.log('Play failed:', e));
      const btn = document.getElementById('videoPlayPauseBtn');
      if (btn) btn.textContent = 'Pause';
    };

    window.loadVideoSource = function() {
      const select = document.getElementById('videoUrlSelect');
      if (!select || !videoElement) return;

      // Parse selected value (format: "charId:videoType")
      const selectedKey = select.value;
      const videoData = VIDEO_CHARACTERS[selectedKey];
      if (videoData) {
        currentVideoCharacter = videoData.charId;
        currentVideoType = videoData.videoType;
      }

      // Load video from config
      const videoConfig = config?.characters?.[currentVideoCharacter]?.video?.[currentVideoType];
      const videoUrl = videoConfig?.url || videoData?.url || './videos/Ksenia_driver.mp4';
      videoElement.src = videoUrl;
      videoElement.load();

      // Pause and reset to frame 0
      videoElement.pause();
      videoElement.currentTime = 0;
      document.getElementById('videoPlayPauseBtn').textContent = 'Play';
      currentTime = 0;
      document.getElementById('timelineSlider').value = 0;

      // Reload settings for the new character
      loadVideoSettings();
      updateVideoBillboard();
    };

    window.updateVisibilityToggle = function() {
      // 3D character rendering disabled
      const show2D = document.getElementById('show2DVideo')?.checked ?? true;

      if (editorMode === 'video') {
        if (videoBillboardGroup) videoBillboardGroup.visible = show2D;
      }
    };

    // Load video settings from config to sliders
    function loadVideoSettings() {
      // Ensure nested structure exists
      if (!config.characters) config.characters = {};
      if (!config.characters[currentVideoCharacter]) config.characters[currentVideoCharacter] = {};
      if (!config.characters[currentVideoCharacter].video) config.characters[currentVideoCharacter].video = {};
      if (!config.characters[currentVideoCharacter].video[currentVideoType]) {
        // Create default config for this video character/type
        const videoKey = `${currentVideoCharacter}:${currentVideoType}`;
        const defaultUrl = VIDEO_CHARACTERS[videoKey]?.url || `./videos/${currentVideoCharacter}_${currentVideoType}.mp4`;
        config.characters[currentVideoCharacter].video[currentVideoType] = {
          url: defaultUrl,
          offset: { x: 0, y: 0, z: 0 },
          pivot: { x: 0, y: 0 },
          scale: 1,
          chromaKey: { color: '#00ff00', threshold: 0.4, smoothing: 0.1 },
          backswingTopTime: 0.8,
          impactTime: 1.0,
        };
      }

      const vc = config.characters[currentVideoCharacter].video[currentVideoType];

      // Update dropdown selection to match current character/type
      const selectKey = `${currentVideoCharacter}:${currentVideoType}`;
      const select = document.getElementById('videoUrlSelect');
      if (select) {
        for (let i = 0; i < select.options.length; i++) {
          if (select.options[i].value === selectKey) {
            select.selectedIndex = i;
            break;
          }
        }
      }

      // Pivot
      document.getElementById('videoPivotX').value = vc.pivot?.x ?? 0;
      document.getElementById('videoPivotY').value = vc.pivot?.y ?? 0;

      // Scale
      document.getElementById('videoScale').value = vc.scale ?? 1;

      // Chroma key
      document.getElementById('chromaKeyColor').value = vc.chromaKey?.color ?? '#00ff00';
      document.getElementById('chromaThreshold').value = vc.chromaKey?.threshold ?? 0.4;
      document.getElementById('chromaSmoothing').value = vc.chromaKey?.smoothing ?? 0.1;

      // Timing
      document.getElementById('videoBackswingTopTime').value = vc.backswingTopTime ?? 0.8;
      document.getElementById('videoImpactTime').value = vc.impactTime ?? 1.0;

      // Update displays
      updateAllVideoDisplays();

      // Apply chroma key
      updateChromaKey();
    }

    // Update all video slider displays
    function updateAllVideoDisplays() {
      ['videoPivotX', 'videoPivotY', 'videoScale', 'videoBackswingTopTime', 'videoImpactTime'].forEach(id => {
        const slider = document.getElementById(id);
        if (slider) updateVideoSliderDisplay(slider);
      });
      // Chroma displays
      document.getElementById('chromaThresholdVal').value = parseFloat(document.getElementById('chromaThreshold').value).toFixed(2);
      document.getElementById('chromaSmoothingVal').value = parseFloat(document.getElementById('chromaSmoothing').value).toFixed(2);
    }

    // Save video settings from sliders to config
    window.saveVideoSettings = function() {
      // Ensure nested structure exists
      if (!config.characters) config.characters = {};
      if (!config.characters[currentVideoCharacter]) config.characters[currentVideoCharacter] = {};
      if (!config.characters[currentVideoCharacter].video) config.characters[currentVideoCharacter].video = {};
      if (!config.characters[currentVideoCharacter].video[currentVideoType]) config.characters[currentVideoCharacter].video[currentVideoType] = {};

      const vc = config.characters[currentVideoCharacter].video[currentVideoType];

      // Get URL from video data
      const videoKey = `${currentVideoCharacter}:${currentVideoType}`;
      vc.url = VIDEO_CHARACTERS[videoKey]?.url ?? `./videos/${currentVideoCharacter}_${currentVideoType}.mp4`;
      // offset removed - pivot point is always at tee position
      vc.offset = { x: 0, y: 0, z: 0 };
      vc.pivot = {
        x: parseFloat(document.getElementById('videoPivotX').value),
        y: parseFloat(document.getElementById('videoPivotY').value),
      };
      vc.scale = parseFloat(document.getElementById('videoScale').value);
      vc.chromaKey = {
        color: document.getElementById('chromaKeyColor').value,
        threshold: parseFloat(document.getElementById('chromaThreshold').value),
        smoothing: parseFloat(document.getElementById('chromaSmoothing').value),
      };

      // Timing
      vc.backswingTopTime = parseFloat(document.getElementById('videoBackswingTopTime').value);
      vc.impactTime = parseFloat(document.getElementById('videoImpactTime').value);

      broadcastConfig();
    };

    // Global functions for onclick handlers (Golf editor keyframe controls removed)
    window.addKeyframe = function() {
      // Keyframe controls removed - keyframes managed via config.json
    };

    window.updateKeyframe = function() {
      // Keyframe controls removed - keyframes managed via config.json

      updateKeyframeList();
      broadcastConfig();
      showStatus('Keyframe updated', 'saved');
    };

    window.gotoKeyframe = function(index) {
      const keyframes = config.characters[currentCharacter]?.[currentAnimation]?.keyframes;
      if (!keyframes?.[index]) return;

      setAnimationTime(keyframes[index].time);
    };

    // Fine adjustment for Golf Editor sliders
    window.adjustValue = function(id, delta) {
      saveUndoState();
      const slider = document.getElementById(id);
      let value = parseFloat(slider.value) + delta;
      value = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), value));
      slider.value = value;
      updateDisplay(id);

      // Trigger appropriate update based on slider type
      if (id.startsWith('club')) {
        updateClubTransform();
      } else if (id.startsWith('ball')) {
        updateBallPosition();
        updateBallConfig();
      }
      broadcastConfig();
    };

    // Fine adjustment for Club Model Editor sliders
    window.adjustModelValue = function(id, delta) {
      saveUndoState();
      const slider = document.getElementById(id);
      let value = parseFloat(slider.value) + delta;
      value = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), value));
      slider.value = value;
      updateClubModelDisplays();
      updateStandaloneClubTransform();
      applyClubModelToConfig();
      updateGolfEditorClubModel();
      broadcastConfig();
    };

    window.deleteKeyframe = function(index) {
      saveUndoState();
      const keyframes = config.characters[currentCharacter]?.[currentAnimation]?.keyframes;
      if (!keyframes) return;

      keyframes.splice(index, 1);
      updateKeyframeList();
      broadcastConfig();
      showStatus('Keyframe deleted', 'saved');
    };

    window.togglePlay = function() {
      isPlaying = !isPlaying;
      document.getElementById('playPauseBtn').textContent = isPlaying ? '||' : '>';

      // Control video playback for video characters
      if (isVideoCharacter(currentCharacter) && videoElement) {
        if (isPlaying) {
          videoElement.play().catch(e => console.log('Video play blocked:', e));
        } else {
          videoElement.pause();
        }
      }
    };

    window.skipToStart = function() {
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = '>';
      if (isVideoCharacter(currentCharacter) && videoElement) {
        videoElement.pause();
      }
      setAnimationTime(0);
    };

    window.skipToEnd = function() {
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = '>';
      if (isVideoCharacter(currentCharacter) && videoElement) {
        videoElement.pause();
      }
      setAnimationTime(animationDuration);
    };

    window.stepBack = function() {
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = '>';
      setAnimationTime(currentTime - 1 / FPS);
    };

    window.stepForward = function() {
      isPlaying = false;
      document.getElementById('playPauseBtn').textContent = '>';
      setAnimationTime(currentTime + 1 / FPS);
    };

    // Character default controls removed with Golf Editor
    window.loadCharacterDefault = function() {
      // Character default controls removed
    };

    window.setAsCharacterDefault = function() {
      // Character default controls removed
    };

    // Helper: Ensure character config exists
    function ensureCharacterConfig() {
      if (!config.characters[currentCharacter]) {
        config.characters[currentCharacter] = {
          club: { ...config.defaults.club },
        };
      }
      if (!config.characters[currentCharacter].club) {
        config.characters[currentCharacter].club = { ...config.defaults.club };
      }
    }

    window.saveConfig = async function() {
      // Always save to localStorage for real-time sync
      localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
      broadcastConfig();

      // If file is linked, also save to file
      if (configFileHandle) {
        const success = await writeConfigToFile();
        if (success) {
          showStatus('Saved to ' + configFilePath, 'saved');
        } else {
          showStatus('Saved to localStorage (file save failed)', 'saved');
        }
      } else {
        showStatus('Saved to localStorage (no file linked)', 'saved');
      }
    };

    // Write config to the linked file (preserves camera settings in video mode)
    async function writeConfigToFilePreservingCamera() {
      if (!configFileHandle) {
        return false;
      }

      try {
        const hasPermission = await verifyFilePermission(configFileHandle);
        if (!hasPermission) {
          throw new Error('Permission denied');
        }

        // Read existing file to preserve camera settings
        let existingConfig = null;
        try {
          const file = await configFileHandle.getFile();
          const text = await file.text();
          existingConfig = JSON.parse(text);
        } catch (e) {
          // If can't read, just write current config
        }

        // Merge: keep existing camera settings, update video settings
        let configToSave = JSON.parse(JSON.stringify(config));
        if (existingConfig?.defaults?.selectionCamera) {
          configToSave.defaults.selectionCamera = existingConfig.defaults.selectionCamera;
        }
        if (existingConfig?.defaults?.playCamera) {
          configToSave.defaults.playCamera = existingConfig.defaults.playCamera;
        }

        const writable = await configFileHandle.createWritable();
        const json = JSON.stringify(configToSave, null, 2);
        await writable.write(json);
        await writable.close();
        return true;
      } catch (e) {
        console.error('Failed to write config to file:', e);
        return false;
      }
    }

    // Save config for video/character tab only (preserves camera settings)
    window.saveVideoConfig = async function() {
      // Save video settings to config first
      saveVideoSettings();

      // Always save to localStorage for real-time sync
      localStorage.setItem(STORAGE_KEY, JSON.stringify(config));
      broadcastConfig();

      // If file is linked, save with camera preservation
      if (configFileHandle) {
        const success = await writeConfigToFilePreservingCamera();
        if (success) {
          showStatus('Saved to ' + configFilePath + ' (camera preserved)', 'saved');
        } else {
          showStatus('Saved to localStorage (file save failed)', 'saved');
        }
      } else {
        showStatus('Saved to localStorage (no file linked)', 'saved');
      }
    };

    // File linking handlers
    window.handleLinkFile = async function() {
      const selected = await selectConfigFile();
      if (selected) {
        showStatus('File linked: ' + configFilePath, 'saved');
      }
    };

    window.handleUnlinkFile = async function() {
      await unlinkConfigFile();
    };

    window.handleLoadFromFile = async function() {
      if (!configFileHandle) {
        // If no file linked, prompt to select one
        const selected = await selectConfigFile();
        if (!selected) return;
      }

      const loadedConfig = await readConfigFromFile();
      if (loadedConfig) {
        config = loadedConfig;

        // Ensure clubs section exists and merge with defaults
        if (!config.clubs) config.clubs = {};
        Object.keys(CLUB_MODEL_PATHS).forEach(clubId => {
          if (!config.clubs[clubId]) {
            config.clubs[clubId] = { ...DEFAULT_CLUB_MODEL };
          }
        });

        loadCharacterConfig();
        loadBallConfig();
        loadImpactConfig();
        loadBackswingTopConfig();
        updateKeyframeList();
        updateClubFromKeyframes();
        broadcastConfig();
        showStatus('Loaded from ' + configFilePath, 'saved');
      } else {
        showStatus('Failed to load from file', 'ready');
      }
    };

    window.exportConfig = function() {
      const json = JSON.stringify(config, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);

      const a = document.createElement('a');
      a.href = url;
      a.download = 'config.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      showStatus('Exported! Replace public/config.json with the downloaded file.', 'saved');
    };

    window.importConfig = function() {
      document.getElementById('fileInput').click();
    };

    window.handleFileImport = function(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const imported = JSON.parse(e.target.result);
          // Validate new config format
          if (imported?.defaults && imported?.characters) {
            config = imported;
            populateVideoCharactersFromConfig();
            loadCharacterConfig();
            loadBallConfig();
            loadImpactConfig();
            loadBackswingTopConfig();
            updateKeyframeList();
            updateClubFromKeyframes();
            broadcastConfig();
            showStatus('Config imported successfully!', 'saved');
          } else {
            showStatus('Invalid config format (missing defaults or characters)', 'ready');
          }
        } catch (err) {
          showStatus('Failed to parse JSON file', 'ready');
        }
      };
      reader.readAsText(file);
      event.target.value = '';
    };

    window.resetToDefault = async function() {
      try {
        const res = await fetch('/config.json');
        config = await res.json();
      } catch (e) {
        config = JSON.parse(JSON.stringify(DEFAULT_CONFIG));
      }

      populateVideoCharactersFromConfig();
      loadCharacterConfig();
      loadBallConfig();
      loadImpactConfig();
      loadBackswingTopConfig();
      updateKeyframeList();
      updateClubFromKeyframes();
      broadcastConfig();
      showStatus('Reset to defaults', 'saved');
    };

    function broadcastConfig() {
      channel.postMessage({ type: 'motion', config });
    }

    function showStatus(message, type) {
      const status = document.getElementById('status');
      status.textContent = message;
      status.className = 'status ' + type;

      if (type === 'saved') {
        setTimeout(() => {
          status.textContent = 'Ready - Changes broadcast in real-time';
          status.className = 'status ready';
        }, 2000);
      }
    }

    // ==================== SCENE MANAGEMENT ====================

    // Scene constants
    const SCENE_CHANNEL_NAME = 'swing-girls-scene-config';
    const SCENE_FILE_HANDLE_KEY = 'sceneFileHandle';
    const SCENE_VERSION = '1.0';

    // Scene state
    let sceneConfig = null;
    let sceneFileHandle = null;
    let sceneFilePath = null;
    let selectedSceneNode = null; // { type: 'terrain'|'splat'|'teeBox'|'prop', id: string }
    let sceneChannel = null;
    let sceneRepeatInterval = null;
    let sceneObjects = new Map(); // Map<id, THREE.Object3D> for click selection
    let transformControls = null; // TransformControls gizmo
    let currentGizmoMode = 'translate'; // 'translate', 'rotate', 'scale'
    let currentGizmoSpace = 'world'; // 'world', 'local'

    // Initialize TransformControls for scene editor
    function initTransformControls() {
      if (!camera || !renderer || !scene) return;

      try {
        transformControls = new TransformControls(camera, renderer.domElement);
        transformControls.setMode('translate');
        transformControls.setSpace('world');
        transformControls.visible = false;

        // Note: CDN module loading breaks TransformControls prototype chain
        // Cannot add to scene - use slider controls for transforms instead
        // The gizmo won't render but attach/detach still works for object tracking

        // Disable OrbitControls while dragging gizmo
        transformControls.addEventListener('dragging-changed', (event) => {
          if (controls) {
            controls.enabled = !event.value;
          }
        });
      } catch (e) {
        console.error('Failed to initialize TransformControls:', e);
        transformControls = null;
        return;
      }

      // Update sliders when gizmo is moved
      transformControls.addEventListener('change', () => {
        if (editorMode !== 'scene' || !selectedSceneNode || !transformControls.object) return;

        const obj = transformControls.object;
        const pos = obj.position;
        const rot = obj.rotation;
        const scl = obj.scale;

        // Update position sliders
        document.getElementById('scenePosX').value = pos.x;
        document.getElementById('scenePosY').value = pos.y;
        document.getElementById('scenePosZ').value = pos.z;
        document.getElementById('scenePosXVal').value = pos.x.toFixed(3);
        document.getElementById('scenePosYVal').value = pos.y.toFixed(3);
        document.getElementById('scenePosZVal').value = pos.z.toFixed(3);

        // Update rotation sliders (convert radians to degrees)
        const rotX = rot.x * (180 / Math.PI);
        const rotY = rot.y * (180 / Math.PI);
        const rotZ = rot.z * (180 / Math.PI);
        document.getElementById('sceneRotX').value = rotX;
        document.getElementById('sceneRotY').value = rotY;
        document.getElementById('sceneRotZ').value = rotZ;
        document.getElementById('sceneRotXVal').value = rotX.toFixed(1);
        document.getElementById('sceneRotYVal').value = rotY.toFixed(1);
        document.getElementById('sceneRotZVal').value = rotZ.toFixed(1);

        // Update scale slider (use uniform scale)
        const uniformScale = scl.x;
        document.getElementById('sceneScale').value = uniformScale;
        document.getElementById('sceneScaleVal').value = uniformScale.toFixed(3);

        // Update scene config
        applyGizmoToConfig();
      });

      // Broadcast on drag end
      transformControls.addEventListener('mouseUp', () => {
        broadcastSceneConfig();
      });
    }

    // Apply gizmo transform to scene config
    function applyGizmoToConfig() {
      if (!selectedSceneNode || !sceneConfig || !transformControls?.object) return;

      const obj = transformControls.object;
      const pos = obj.position;
      const rot = obj.rotation;
      const scl = obj.scale;

      let node = null;
      if (selectedSceneNode.type === 'terrain') {
        node = sceneConfig.terrain;
      } else if (selectedSceneNode.type === 'splat') {
        node = sceneConfig.splat;
      } else if (selectedSceneNode.type === 'teeBox') {
        node = sceneConfig.teeBox;
      } else if (selectedSceneNode.type === 'tee') {
        node = sceneConfig.teeBox.tee;
      } else if (selectedSceneNode.type === 'prop') {
        node = sceneConfig.props.find(p => p.id === selectedSceneNode.id);
      }

      if (!node) return;

      // Position - for tee, calculate relative position to teeBox (reverse hierarchical transform)
      if (selectedSceneNode.type === 'tee') {
        const teeBox = sceneConfig.teeBox;
        // Get world offset from teeBox
        const worldOffset = new THREE.Vector3(
          pos.x - (teeBox.position?.x ?? 0),
          pos.y - (teeBox.position?.y ?? 0),
          pos.z - (teeBox.position?.z ?? 0)
        );
        // Reverse parent rotation to get local position
        const parentRot = new THREE.Euler(
          (teeBox.rotation?.x ?? 0) * DEG_TO_RAD,
          (teeBox.rotation?.y ?? 0) * DEG_TO_RAD,
          (teeBox.rotation?.z ?? 0) * DEG_TO_RAD
        );
        const inverseQuat = new THREE.Quaternion().setFromEuler(parentRot).invert();
        worldOffset.applyQuaternion(inverseQuat);
        node.position = {
          x: worldOffset.x,
          y: worldOffset.y,
          z: worldOffset.z,
        };
      } else {
        node.position = { x: pos.x, y: pos.y, z: pos.z };
      }

      // Rotation (in degrees)
      node.rotation = {
        x: rot.x * (180 / Math.PI),
        y: rot.y * (180 / Math.PI),
        z: rot.z * (180 / Math.PI),
      };

      // Scale
      if (selectedSceneNode.type === 'terrain' || selectedSceneNode.type === 'splat' || selectedSceneNode.type === 'teeBox' || selectedSceneNode.type === 'tee') {
        node.scale = scl.x;
      } else if (selectedSceneNode.type === 'prop') {
        node.scale = { x: scl.x, y: scl.y, z: scl.z };
      }

      // Update actual 3D meshes to follow gizmo
      if (selectedSceneNode.type === 'terrain' && terrainMesh) {
        terrainMesh.position.copy(pos);
        terrainMesh.rotation.copy(rot);
        terrainMesh.scale.setScalar(scl.x);
      } else if (selectedSceneNode.type === 'splat' && splatMesh) {
        splatMesh.position.copy(pos);
        splatMesh.rotation.copy(rot);
        splatMesh.scale.setScalar(scl.x);
      }

      // When TeeBox moves/rotates, also update Tee child proxy (hierarchical transform)
      if (selectedSceneNode.type === 'teeBox' && sceneConfig.teeBox.tee) {
        const teeObj = sceneObjects.get(sceneConfig.teeBox.tee.id);
        if (teeObj) {
          const tee = sceneConfig.teeBox.tee;
          // Apply parent rotation to child's relative position
          const childRelPos = new THREE.Vector3(
            tee.position?.x ?? 0,
            tee.position?.y ?? 0,
            tee.position?.z ?? 0
          );
          childRelPos.applyEuler(rot);
          teeObj.position.set(
            pos.x + childRelPos.x,
            pos.y + childRelPos.y,
            pos.z + childRelPos.z
          );
        }
      }

      // Update character proxy and actual character when teeBox or tee moves
      if (selectedSceneNode.type === 'teeBox' || selectedSceneNode.type === 'tee') {
        updateCharacterProxy();
        updateCharacterPosition(); // Also move the actual 3D character
        updateVideoBillboard(); // Also move the video character
      }
    }

    // Attach gizmo to selected scene object
    function attachGizmoToSelectedNode() {
      if (!transformControls || !selectedSceneNode) {
        if (transformControls) {
          transformControls.detach();
          transformControls.visible = false;
        }
        return;
      }

      const obj = sceneObjects.get(selectedSceneNode.id);
      if (obj) {
        transformControls.attach(obj);
        transformControls.visible = true;
        transformControls.setMode(currentGizmoMode);
        transformControls.setSpace(currentGizmoSpace);
      } else {
        transformControls.detach();
        transformControls.visible = false;
      }
    }

    // Default scene configuration
    const DEFAULT_SCENE_CONFIG = {
      version: SCENE_VERSION,
      name: 'Urban Golf Range',
      description: 'Rooftop driving range scene',
      terrain: {
        id: 'terrain-001',
        name: 'Main Terrain',
        url: '/terrains/terrain.terrain',
        position: { x: 0, y: 0, z: 100 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: 1,
        visible: true,
      },
      splat: {
        id: 'splat-001',
        name: 'Background Splat',
        url: '/splats/Urban-Golf-Range.ply',
        position: { x: 0, y: 0, z: 0 },
        rotation: { x: 0, y: 180, z: 180 },
        scale: 16.537,
        visible: true,
      },
      teeBox: {
        id: 'tee-001',
        name: 'Tee Box',
        url: './models/teebox/Teebox.glb',
        position: { x: 0, y: 0, z: 0 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: 1,
        visible: true,
        tee: {
          id: 'tee-peg-001',
          name: 'Tee',
          position: { x: 0, y: 0, z: 0 },
          rotation: { x: 0, y: 0, z: 0 },
          scale: 1,
          visible: true,
        },
      },
      props: [],
    };

    // Initialize scene editor
    function initSceneEditor() {
      // Initialize scene BroadcastChannel
      if (!sceneChannel) {
        sceneChannel = new BroadcastChannel(SCENE_CHANNEL_NAME);
      }

      if (!sceneConfig) {
        // No scene config loaded - create default and sync from existing meshes
        sceneConfig = JSON.parse(JSON.stringify(DEFAULT_SCENE_CONFIG));
        syncSceneConfigWithActualMeshes();
      } else {
        // Scene config exists (loaded from file) - apply it to meshes
        applySceneConfigToMeshes();
      }

      // Ensure character is positioned based on tee (covers both paths)
      updateCharacterPosition();
      updateVideoBillboard();

      // Update UI
      document.getElementById('sceneNameInput').value = sceneConfig.name || 'Untitled Scene';
      renderSceneTree();
      updateSceneFileStatusUI();

      // Initialize 3D proxy objects for scene editing
      initSceneEditorRendering();
    }

    // Sync scene config with actual terrain/splat mesh positions
    function syncSceneConfigWithActualMeshes() {
      if (!sceneConfig) return;

      // Sync terrain position from actual terrain mesh
      if (terrainMesh) {
        sceneConfig.terrain.position = {
          x: terrainMesh.position.x,
          y: terrainMesh.position.y,
          z: terrainMesh.position.z,
        };
        sceneConfig.terrain.rotation = {
          x: terrainMesh.rotation.x * RAD_TO_DEG,
          y: terrainMesh.rotation.y * RAD_TO_DEG,
          z: terrainMesh.rotation.z * RAD_TO_DEG,
        };
        sceneConfig.terrain.scale = terrainMesh.scale.x;
        sceneConfig.terrain.visible = terrainMesh.visible;
      }

      // Sync splat position from actual splat mesh
      if (splatMesh) {
        sceneConfig.splat.position = {
          x: splatMesh.position.x,
          y: splatMesh.position.y,
          z: splatMesh.position.z,
        };
        sceneConfig.splat.rotation = {
          x: splatMesh.rotation.x * RAD_TO_DEG,
          y: splatMesh.rotation.y * RAD_TO_DEG,
          z: splatMesh.rotation.z * RAD_TO_DEG,
        };
        sceneConfig.splat.scale = splatMesh.scale.x;
        sceneConfig.splat.visible = splatMesh.visible;
      }
    }

    // Apply scene config to actual 3D meshes (reverse of syncSceneConfigWithActualMeshes)
    function applySceneConfigToMeshes() {
      if (!sceneConfig) return;

      // Apply terrain config to terrain mesh
      if (terrainMesh) {
        terrainMesh.position.set(
          sceneConfig.terrain.position.x,
          sceneConfig.terrain.position.y,
          sceneConfig.terrain.position.z
        );
        terrainMesh.rotation.set(
          sceneConfig.terrain.rotation.x * DEG_TO_RAD,
          sceneConfig.terrain.rotation.y * DEG_TO_RAD,
          sceneConfig.terrain.rotation.z * DEG_TO_RAD
        );
        const terrainScale = sceneConfig.terrain.scale ?? 1;
        terrainMesh.scale.set(terrainScale, terrainScale, terrainScale);
        terrainMesh.visible = sceneConfig.terrain.visible;
      }

      // Apply splat config to splat mesh
      if (splatMesh) {
        splatMesh.position.set(
          sceneConfig.splat.position.x,
          sceneConfig.splat.position.y,
          sceneConfig.splat.position.z
        );
        splatMesh.rotation.set(
          sceneConfig.splat.rotation.x * DEG_TO_RAD,
          sceneConfig.splat.rotation.y * DEG_TO_RAD,
          sceneConfig.splat.rotation.z * DEG_TO_RAD
        );
        const splatScale = sceneConfig.splat.scale ?? 1;
        splatMesh.scale.set(splatScale, splatScale, splatScale);
        splatMesh.visible = sceneConfig.splat.visible;
      }

      // Update character position based on tee position
      updateCharacterPosition();
      updateVideoBillboard();

      console.log('Applied scene config to meshes:', {
        terrain: sceneConfig.terrain,
        splat: sceneConfig.splat,
        teeBox: sceneConfig.teeBox
      });
    }

    // Render the scene tree view
    function renderSceneTree() {
      const container = document.getElementById('sceneTree');
      if (!container || !sceneConfig) return;

      let html = '';

      // Terrain group
      html += `
        <div class="tree-group" id="treeGroupTerrain">
          <div class="tree-group-header" onclick="toggleTreeGroup('treeGroupTerrain')">
            <span class="toggle-icon">v</span>
            Terrain
          </div>
          <div class="tree-group-children">
            <div class="tree-node ${selectedSceneNode?.id === sceneConfig.terrain.id ? 'selected' : ''}"
                 onclick="selectSceneNode('terrain', '${sceneConfig.terrain.id}')"
                 data-id="${sceneConfig.terrain.id}">
              <span class="node-icon">[T]</span>
              <span class="node-name">${sceneConfig.terrain.name}</span>
              <span class="node-visibility ${sceneConfig.terrain.visible ? '' : 'hidden'}"
                    onclick="toggleSceneNodeVisibility(event, 'terrain', '${sceneConfig.terrain.id}')">
                ${sceneConfig.terrain.visible ? '[O]' : '[X]'}
              </span>
            </div>
          </div>
        </div>
      `;

      // Splat group
      html += `
        <div class="tree-group" id="treeGroupSplat">
          <div class="tree-group-header" onclick="toggleTreeGroup('treeGroupSplat')">
            <span class="toggle-icon">v</span>
            Gaussian Splat
          </div>
          <div class="tree-group-children">
            <div class="tree-node ${selectedSceneNode?.id === sceneConfig.splat.id ? 'selected' : ''}"
                 onclick="selectSceneNode('splat', '${sceneConfig.splat.id}')"
                 data-id="${sceneConfig.splat.id}">
              <span class="node-icon">[S]</span>
              <span class="node-name">${sceneConfig.splat.name}</span>
              <span class="node-visibility ${sceneConfig.splat.visible ? '' : 'hidden'}"
                    onclick="toggleSceneNodeVisibility(event, 'splat', '${sceneConfig.splat.id}')">
                ${sceneConfig.splat.visible ? '[O]' : '[X]'}
              </span>
            </div>
          </div>
        </div>
      `;

      // Tee Box group
      html += `
        <div class="tree-group" id="treeGroupTeeBox">
          <div class="tree-group-header" onclick="toggleTreeGroup('treeGroupTeeBox')">
            <span class="toggle-icon">v</span>
            Tee Box
          </div>
          <div class="tree-group-children">
            <div class="tree-node ${selectedSceneNode?.id === sceneConfig.teeBox.id ? 'selected' : ''}"
                 onclick="selectSceneNode('teeBox', '${sceneConfig.teeBox.id}')"
                 data-id="${sceneConfig.teeBox.id}">
              <span class="node-icon">[B]</span>
              <span class="node-name">${sceneConfig.teeBox.name}</span>
            </div>
            <div class="tree-node child-node ${selectedSceneNode?.id === sceneConfig.teeBox.tee?.id ? 'selected' : ''}"
                 onclick="selectSceneNode('tee', '${sceneConfig.teeBox.tee?.id}')"
                 data-id="${sceneConfig.teeBox.tee?.id}"
                 style="padding-left: 24px;">
              <span class="node-icon">[T]</span>
              <span class="node-name">${sceneConfig.teeBox.tee?.name || 'Tee'}</span>
            </div>
          </div>
        </div>
      `;

      // Props group
      html += `
        <div class="tree-group" id="treeGroupProps">
          <div class="tree-group-header" onclick="toggleTreeGroup('treeGroupProps')">
            <span class="toggle-icon">v</span>
            Props (${sceneConfig.props.length})
          </div>
          <div class="tree-group-children">
      `;

      if (sceneConfig.props.length === 0) {
        html += `<div style="font-size: 11px; color: #666; padding: 8px;">No props added</div>`;
      } else {
        sceneConfig.props.forEach(prop => {
          html += `
            <div class="tree-node ${selectedSceneNode?.id === prop.id ? 'selected' : ''}"
                 onclick="selectSceneNode('prop', '${prop.id}')"
                 data-id="${prop.id}">
              <span class="node-icon">[P]</span>
              <span class="node-name">${prop.name}</span>
              <span class="node-visibility ${prop.visible ? '' : 'hidden'}"
                    onclick="toggleSceneNodeVisibility(event, 'prop', '${prop.id}')">
                ${prop.visible ? '[O]' : '[X]'}
              </span>
            </div>
          `;
        });
      }

      // Add Prop / Delete buttons inside Props group
      html += `
        <div style="display: flex; gap: 6px; padding: 8px 4px; margin-top: 4px;">
          <button class="add" onclick="showAddPropDialog()" style="flex: 1; padding: 4px 8px; font-size: 11px;">+ Add</button>
          <button class="secondary" onclick="deleteSelectedNode()" style="flex: 1; padding: 4px 8px; font-size: 11px;">Delete</button>
        </div>
      `;

      html += `</div></div>`;

      container.innerHTML = html;
    }

    // Toggle tree group collapse
    window.toggleTreeGroup = function(groupId) {
      const group = document.getElementById(groupId);
      if (group) {
        group.classList.toggle('collapsed');
      }
    };

    // Select a scene node
    window.selectSceneNode = function(type, id) {
      selectedSceneNode = { type, id };
      renderSceneTree();
      loadSelectedNodeTransform();
      showTransformControls(true);
      attachGizmoToSelectedNode();
    };

    // Update file URL display for selected terrain/splat node
    function updateSceneNodeFileDisplay() {
      const urlInput = document.getElementById('sceneNodeUrl');
      if (!urlInput || !selectedSceneNode) return;

      let url = '';
      if (selectedSceneNode.type === 'terrain') {
        url = sceneConfig.terrain?.url || '';
      } else if (selectedSceneNode.type === 'splat') {
        url = sceneConfig.splat?.url || '';
      }

      urlInput.value = url;
      urlInput.title = url || 'No file selected';
    }

    // Browse for terrain/splat file
    window.browseSceneNodeFile = async function() {
      if (!selectedSceneNode) return;

      try {
        let fileTypes, folder;
        if (selectedSceneNode.type === 'terrain') {
          fileTypes = [{ description: 'Terrain Files', accept: { 'application/json': ['.terrain'] } }];
          folder = '/terrains/';
        } else if (selectedSceneNode.type === 'splat') {
          fileTypes = [{ description: 'Splat Files', accept: { 'application/octet-stream': ['.ply', '.splat'] } }];
          folder = '/splats/';
        } else {
          return;
        }

        const [handle] = await window.showOpenFilePicker({
          types: fileTypes,
          multiple: false
        });

        const file = await handle.getFile();
        const url = folder + file.name;

        // Update sceneConfig
        if (selectedSceneNode.type === 'terrain') {
          sceneConfig.terrain.url = url;
          await window.reloadTerrain();
        } else if (selectedSceneNode.type === 'splat') {
          sceneConfig.splat.url = url;
          await window.reloadSplat();
        }

        // Update UI
        updateSceneNodeFileDisplay();
        broadcastSceneConfig();
        showStatus('File changed: ' + file.name, 'saved');
      } catch (err) {
        if (err.name !== 'AbortError') {
          console.error('Failed to browse file:', err);
          showStatus('Failed to load file', 'error');
        }
      }
    };

    // Clear terrain/splat file
    window.clearSceneNodeFile = async function() {
      if (!selectedSceneNode) return;

      if (selectedSceneNode.type === 'terrain') {
        sceneConfig.terrain.url = null;
        sceneConfig.terrain.visible = false;
        if (terrainMesh) {
          scene.remove(terrainMesh);
          terrainMesh.geometry.dispose();
          terrainMesh.material.dispose();
          terrainMesh = null;
        }
        terrainData = null;
        terrainUniforms = null;
      } else if (selectedSceneNode.type === 'splat') {
        sceneConfig.splat.url = null;
        sceneConfig.splat.visible = false;
        if (splatMesh) {
          scene.remove(splatMesh);
          splatMesh = null;
        }
      }

      // Update UI
      updateSceneNodeFileDisplay();
      document.getElementById('sceneNodeVisible').checked = false;
      renderSceneTree();
      broadcastSceneConfig();
      showStatus('File cleared', 'saved');
    };

    // Toggle visibility of a scene node
    window.toggleSceneNodeVisibility = function(event, type, id) {
      event.stopPropagation();

      let newVisible = false;
      if (type === 'terrain') {
        sceneConfig.terrain.visible = !sceneConfig.terrain.visible;
        newVisible = sceneConfig.terrain.visible;
        // Update actual terrain mesh
        if (terrainMesh) terrainMesh.visible = newVisible;
      } else if (type === 'splat') {
        sceneConfig.splat.visible = !sceneConfig.splat.visible;
        newVisible = sceneConfig.splat.visible;
        // Update actual splat mesh
        if (splatMesh) splatMesh.visible = newVisible;
      } else if (type === 'teeBox') {
        sceneConfig.teeBox.visible = !sceneConfig.teeBox.visible;
        newVisible = sceneConfig.teeBox.visible;
      } else if (type === 'tee') {
        sceneConfig.teeBox.tee.visible = !sceneConfig.teeBox.tee.visible;
        newVisible = sceneConfig.teeBox.tee.visible;
      } else if (type === 'prop') {
        const prop = sceneConfig.props.find(p => p.id === id);
        if (prop) {
          prop.visible = !prop.visible;
          newVisible = prop.visible;
        }
      }

      // Update 3D proxy object visibility
      const proxyObj = sceneObjects.get(id);
      if (proxyObj) {
        proxyObj.visible = newVisible;
      }

      renderSceneTree();
      broadcastSceneConfig();
    };

    // Show/hide transform controls
    function showTransformControls(show) {
      const posControls = document.getElementById('scenePositionControls');
      const rotControls = document.getElementById('sceneRotationControls');
      const scaleControls = document.getElementById('sceneScaleControls');
      const visControl = document.getElementById('sceneVisibilityControl');
      const fileControl = document.getElementById('sceneFileControl');
      const assetSelector = document.getElementById('sceneModelSelector');
      const placeholder = document.getElementById('sceneTransformControls');

      if (show && selectedSceneNode) {
        posControls.style.display = 'block';
        rotControls.style.display = 'block';

        // All scene objects have scale
        scaleControls.style.display = 'block';

        // All scene objects have visibility
        visControl.style.display = 'block';

        // Hide file control (replaced by asset selector)
        fileControl.style.display = 'none';

        // Asset selector for terrain, splat, teeBox, and props (not for tee)
        const showAssetSelector = selectedSceneNode.type === 'terrain' ||
                                   selectedSceneNode.type === 'splat' ||
                                   selectedSceneNode.type === 'teeBox' ||
                                   selectedSceneNode.type === 'prop';
        assetSelector.style.display = showAssetSelector ? 'block' : 'none';

        // Update asset library display
        if (showAssetSelector) {
          renderAssetLibrary();
        }

        placeholder.querySelector('p').style.display = 'none';
      } else {
        posControls.style.display = 'none';
        rotControls.style.display = 'none';
        scaleControls.style.display = 'none';
        visControl.style.display = 'none';
        fileControl.style.display = 'none';
        assetSelector.style.display = 'none';
        placeholder.querySelector('p').style.display = 'block';
      }
    }

    // Render the asset library grid for the selected node type
    function renderAssetLibrary() {
      const container = document.getElementById('modelLibraryGrid');
      if (!container || !selectedSceneNode) return;

      // Get asset type and current URL based on selected node
      const assetType = NODE_TYPE_TO_ASSET_TYPE[selectedSceneNode.type];
      if (!assetType) {
        container.innerHTML = '<p style="font-size: 11px; color: #666; text-align: center; padding: 10px;">No assets for this type</p>';
        return;
      }

      const assets = ASSET_LIBRARY[assetType] || [];
      let currentUrl = '';

      if (selectedSceneNode.type === 'terrain') {
        currentUrl = sceneConfig.terrain?.url || '';
      } else if (selectedSceneNode.type === 'splat') {
        currentUrl = sceneConfig.splat?.url || '';
      } else if (selectedSceneNode.type === 'teeBox') {
        currentUrl = sceneConfig.teeBox?.url || '';
      } else if (selectedSceneNode.type === 'prop') {
        const prop = sceneConfig.props.find(p => p.id === selectedSceneNode.id);
        currentUrl = prop?.url || '';
      }

      if (assets.length === 0) {
        container.innerHTML = '<p style="font-size: 11px; color: #666; text-align: center; padding: 10px;">No assets available</p>';
        return;
      }

      // Get asset type label with icon
      const typeInfo = {
        terrain: { label: 'Terrain', icon: '[#]', desc: '.terrain files' },
        splat: { label: 'Splat', icon: '[*]', desc: '.ply/.splat files' },
        mesh: { label: 'Mesh', icon: '[M]', desc: '.glb/.fbx files' }
      };
      const info = typeInfo[assetType] || { label: 'Asset', icon: '[-]', desc: '' };

      let html = `<p class="asset-type-label">${info.label} ${info.desc}</p>`;
      assets.forEach(asset => {
        const isSelected = currentUrl === asset.url;
        html += `
          <div class="model-item ${isSelected ? 'selected' : ''}"
               onclick="selectAsset('${assetType}', '${asset.url}')"
               title="${asset.url}">
            <div class="model-name">${asset.name}</div>
          </div>
        `;
      });

      container.innerHTML = html;
    }

    // Select an asset from the library
    window.selectAsset = async function(assetType, url) {
      if (!selectedSceneNode || !sceneConfig) return;

      const nodeType = selectedSceneNode.type;
      console.log('[AssetLibrary] Selecting', assetType, 'asset:', url, 'for', nodeType);

      if (nodeType === 'terrain') {
        sceneConfig.terrain.url = url;
        // Reload terrain in editor
        await reloadTerrainAsset(url);
      } else if (nodeType === 'splat') {
        sceneConfig.splat.url = url;
        // Reload splat in editor
        await reloadSplatAsset(url);
      } else if (nodeType === 'teeBox') {
        sceneConfig.teeBox.url = url;
        // Reload the TeeBox mesh in the editor
        reloadTeeBoxMesh(url);
      } else if (nodeType === 'prop') {
        const prop = sceneConfig.props.find(p => p.id === selectedSceneNode.id);
        if (prop) {
          prop.url = url;
        }
      }

      // Update UI
      renderAssetLibrary();
      broadcastSceneConfig();
      showStatus(assetType + ' changed: ' + url.split('/').pop(), 'saved');
    };

    // Reload terrain asset
    async function reloadTerrainAsset(newUrl) {
      console.log('[AssetLibrary] Reloading terrain:', newUrl);

      // Remove existing terrain mesh
      if (terrainMesh) {
        scene.remove(terrainMesh);
        terrainMesh.geometry.dispose();
        terrainMesh.material.dispose();
        terrainMesh = null;
      }
      terrainData = null;
      terrainUniforms = null;

      // Load new terrain
      if (newUrl) {
        sceneConfig.terrain.visible = true;
        await loadTerrain();
      }
    }

    // Reload splat asset
    async function reloadSplatAsset(newUrl) {
      console.log('[AssetLibrary] Reloading splat:', newUrl);

      // Remove existing splat
      if (splatMesh) {
        scene.remove(splatMesh);
        splatMesh = null;
      }

      // Load new splat
      if (newUrl) {
        sceneConfig.splat.visible = true;
        await loadSplat();
      }
    }

    // Reload the TeeBox mesh with a new model URL
    function reloadTeeBoxMesh(newUrl) {
      const teeBoxId = sceneConfig.teeBox?.id;
      if (!teeBoxId) return;

      const teeBoxGroup = sceneObjects.get(teeBoxId);
      if (!teeBoxGroup) return;

      // Remove existing model children (keep the group for transform)
      const childrenToRemove = [];
      teeBoxGroup.traverse((child) => {
        if (child !== teeBoxGroup && child.isMesh) {
          childrenToRemove.push(child);
        }
      });
      childrenToRemove.forEach(child => {
        child.parent?.remove(child);
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(m => m.dispose());
          } else {
            child.material.dispose();
          }
        }
      });

      // Clear all children from the group
      while (teeBoxGroup.children.length > 0) {
        teeBoxGroup.remove(teeBoxGroup.children[0]);
      }

      // Load the new model
      const loader = new GLTFLoader();
      loader.load(
        newUrl,
        (gltf) => {
          const model = gltf.scene;
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          teeBoxGroup.add(model);
          console.log('[ModelLibrary] TeeBox mesh reloaded:', newUrl);
        },
        undefined,
        (error) => {
          console.error('[ModelLibrary] Failed to reload TeeBox mesh:', error);
          // Fallback: create a simple marker
          const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
          const poleMaterial = new THREE.MeshBasicMaterial({
            color: 0xfbbf24,
            transparent: true,
            opacity: 0.7,
          });
          const pole = new THREE.Mesh(poleGeometry, poleMaterial);
          pole.position.y = 1;
          teeBoxGroup.add(pole);
        }
      );
    }

    // Load selected node transform to sliders
    function loadSelectedNodeTransform() {
      if (!selectedSceneNode || !sceneConfig) return;

      let node = null;
      if (selectedSceneNode.type === 'terrain') {
        node = sceneConfig.terrain;
      } else if (selectedSceneNode.type === 'splat') {
        node = sceneConfig.splat;
      } else if (selectedSceneNode.type === 'teeBox') {
        node = sceneConfig.teeBox;
      } else if (selectedSceneNode.type === 'tee') {
        node = sceneConfig.teeBox.tee;
      } else if (selectedSceneNode.type === 'prop') {
        node = sceneConfig.props.find(p => p.id === selectedSceneNode.id);
      }

      if (!node) return;

      // Position
      document.getElementById('scenePosX').value = node.position?.x ?? 0;
      document.getElementById('scenePosY').value = node.position?.y ?? 0;
      document.getElementById('scenePosZ').value = node.position?.z ?? 0;
      document.getElementById('scenePosXVal').value = (node.position?.x ?? 0).toFixed(3);
      document.getElementById('scenePosYVal').value = (node.position?.y ?? 0).toFixed(3);
      document.getElementById('scenePosZVal').value = (node.position?.z ?? 0).toFixed(3);

      // Rotation
      document.getElementById('sceneRotX').value = node.rotation?.x ?? 0;
      document.getElementById('sceneRotY').value = node.rotation?.y ?? 0;
      document.getElementById('sceneRotZ').value = node.rotation?.z ?? 0;
      document.getElementById('sceneRotXVal').value = (node.rotation?.x ?? 0).toFixed(1);
      document.getElementById('sceneRotYVal').value = (node.rotation?.y ?? 0).toFixed(1);
      document.getElementById('sceneRotZVal').value = (node.rotation?.z ?? 0).toFixed(1);

      // Scale (terrain, splat, teeBox, tee, and props)
      if (selectedSceneNode.type === 'terrain' || selectedSceneNode.type === 'splat' || selectedSceneNode.type === 'teeBox' || selectedSceneNode.type === 'tee') {
        document.getElementById('sceneScale').value = node.scale ?? 1;
        document.getElementById('sceneScaleVal').value = (node.scale ?? 1).toFixed(3);
      } else if (selectedSceneNode.type === 'prop') {
        // Props have Vector3 scale, use uniform scale for simplicity
        const uniformScale = node.scale?.x ?? 1;
        document.getElementById('sceneScale').value = uniformScale;
        document.getElementById('sceneScaleVal').value = uniformScale.toFixed(3);
      }

      // Visibility
      if (node.visible !== undefined) {
        document.getElementById('sceneNodeVisible').checked = node.visible;
      }
    }

    // Update scene slider display
    window.updateSceneSliderDisplay = function(input) {
      const valInput = document.getElementById(input.id + 'Val');
      if (valInput) {
        const isRotation = input.id.includes('Rot');
        valInput.value = isRotation
          ? parseFloat(input.value).toFixed(1)
          : parseFloat(input.value).toFixed(3);
      }
      applySceneSliderToConfig();
      broadcastSceneConfig();
    };

    // Update scene value from text input
    window.updateSceneValueFromInput = function(textInput, sliderId) {
      const slider = document.getElementById(sliderId);
      if (!slider) return;

      const value = parseFloat(textInput.value);
      if (isNaN(value)) return;

      // Update the slider value
      slider.value = value;

      // Apply changes
      applySceneSliderToConfig();
      broadcastSceneConfig();
    };

    // Start scene repeat adjustment
    window.startSceneRepeat = function(inputId, delta) {
      adjustSceneValue(inputId, delta);
      sceneRepeatInterval = setInterval(() => adjustSceneValue(inputId, delta), 50);
    };

    // Stop scene repeat adjustment
    window.stopSceneRepeat = function() {
      if (sceneRepeatInterval) {
        clearInterval(sceneRepeatInterval);
        sceneRepeatInterval = null;
      }
    };

    // Adjust scene value
    function adjustSceneValue(inputId, delta) {
      const input = document.getElementById(inputId);
      if (!input) return;
      const val = parseFloat(input.value) + delta;
      const min = parseFloat(input.min);
      const max = parseFloat(input.max);
      input.value = Math.max(min, Math.min(max, val));
      updateSceneSliderDisplay(input);
    }

    // Apply scene sliders to config
    function applySceneSliderToConfig() {
      if (!selectedSceneNode || !sceneConfig) return;

      let node = null;
      if (selectedSceneNode.type === 'terrain') {
        node = sceneConfig.terrain;
      } else if (selectedSceneNode.type === 'splat') {
        node = sceneConfig.splat;
      } else if (selectedSceneNode.type === 'teeBox') {
        node = sceneConfig.teeBox;
      } else if (selectedSceneNode.type === 'tee') {
        node = sceneConfig.teeBox.tee;
      } else if (selectedSceneNode.type === 'prop') {
        node = sceneConfig.props.find(p => p.id === selectedSceneNode.id);
      }

      if (!node) return;

      // Position
      node.position = {
        x: parseFloat(document.getElementById('scenePosX').value),
        y: parseFloat(document.getElementById('scenePosY').value),
        z: parseFloat(document.getElementById('scenePosZ').value),
      };

      // Rotation
      node.rotation = {
        x: parseFloat(document.getElementById('sceneRotX').value),
        y: parseFloat(document.getElementById('sceneRotY').value),
        z: parseFloat(document.getElementById('sceneRotZ').value),
      };

      // Scale
      if (selectedSceneNode.type === 'terrain' || selectedSceneNode.type === 'splat' || selectedSceneNode.type === 'teeBox' || selectedSceneNode.type === 'tee') {
        node.scale = parseFloat(document.getElementById('sceneScale').value);
      } else if (selectedSceneNode.type === 'prop') {
        const uniformScale = parseFloat(document.getElementById('sceneScale').value);
        node.scale = { x: uniformScale, y: uniformScale, z: uniformScale };
      }

      // Update 3D proxy object to reflect changes
      const proxyObj = sceneObjects.get(selectedSceneNode.id);
      if (proxyObj) {
        if (selectedSceneNode.type === 'tee') {
          // Tee proxy needs world position with hierarchical transform (parent rotation applied)
          const teeBox = sceneConfig.teeBox;
          const parentRot = new THREE.Euler(
            (teeBox.rotation?.x ?? 0) * DEG_TO_RAD,
            (teeBox.rotation?.y ?? 0) * DEG_TO_RAD,
            (teeBox.rotation?.z ?? 0) * DEG_TO_RAD
          );
          const childRelPos = new THREE.Vector3(
            node.position?.x ?? 0,
            node.position?.y ?? 0,
            node.position?.z ?? 0
          );
          childRelPos.applyEuler(parentRot);
          proxyObj.position.set(
            (teeBox.position?.x ?? 0) + childRelPos.x,
            (teeBox.position?.y ?? 0) + childRelPos.y,
            (teeBox.position?.z ?? 0) + childRelPos.z
          );
          if (node.rotation) {
            proxyObj.rotation.set(
              (node.rotation.x ?? 0) * DEG_TO_RAD,
              (node.rotation.y ?? 0) * DEG_TO_RAD,
              (node.rotation.z ?? 0) * DEG_TO_RAD
            );
          }
          const teeScale = node.scale ?? 1;
          proxyObj.scale.set(teeScale, teeScale, teeScale);
          proxyObj.visible = node.visible !== false;
        } else {
          updateProxyFromNode(proxyObj, node);
        }
      }

      // Update actual 3D meshes (terrain, splat)
      if (selectedSceneNode.type === 'terrain' && terrainMesh) {
        terrainMesh.position.set(node.position.x, node.position.y, node.position.z);
        terrainMesh.rotation.set(
          node.rotation.x * DEG_TO_RAD,
          node.rotation.y * DEG_TO_RAD,
          node.rotation.z * DEG_TO_RAD
        );
        terrainMesh.scale.setScalar(node.scale ?? 1);
        terrainMesh.visible = node.visible !== false;
      } else if (selectedSceneNode.type === 'splat' && splatMesh) {
        splatMesh.position.set(node.position.x, node.position.y, node.position.z);
        splatMesh.rotation.set(
          node.rotation.x * DEG_TO_RAD,
          node.rotation.y * DEG_TO_RAD,
          node.rotation.z * DEG_TO_RAD
        );
        splatMesh.scale.setScalar(node.scale);
        splatMesh.visible = node.visible !== false;
      }

      // When TeeBox moves/rotates, also update Tee child proxy (hierarchical transform)
      if (selectedSceneNode.type === 'teeBox' && sceneConfig.teeBox.tee) {
        const teeObj = sceneObjects.get(sceneConfig.teeBox.tee.id);
        if (teeObj) {
          const tee = sceneConfig.teeBox.tee;
          // Apply parent rotation to child's relative position
          const parentRot = new THREE.Euler(
            (node.rotation?.x ?? 0) * DEG_TO_RAD,
            (node.rotation?.y ?? 0) * DEG_TO_RAD,
            (node.rotation?.z ?? 0) * DEG_TO_RAD
          );
          const childRelPos = new THREE.Vector3(
            tee.position?.x ?? 0,
            tee.position?.y ?? 0,
            tee.position?.z ?? 0
          );
          childRelPos.applyEuler(parentRot);
          teeObj.position.set(
            node.position.x + childRelPos.x,
            node.position.y + childRelPos.y,
            node.position.z + childRelPos.z
          );
        }
      }

      // Update character proxy and actual character when teeBox or tee moves
      if (selectedSceneNode.type === 'teeBox' || selectedSceneNode.type === 'tee') {
        updateCharacterProxy();
        updateCharacterPosition(); // Also move the actual 3D character
        updateVideoBillboard(); // Also move the video character
      }
    }

    // Update scene node visibility from checkbox
    window.updateSceneNodeVisibility = function() {
      if (!selectedSceneNode || !sceneConfig) return;

      const visible = document.getElementById('sceneNodeVisible').checked;

      if (selectedSceneNode.type === 'terrain') {
        sceneConfig.terrain.visible = visible;
        // Update actual terrain mesh
        if (terrainMesh) terrainMesh.visible = visible;
      } else if (selectedSceneNode.type === 'splat') {
        sceneConfig.splat.visible = visible;
        // Update actual splat mesh
        if (splatMesh) splatMesh.visible = visible;
      } else if (selectedSceneNode.type === 'teeBox') {
        sceneConfig.teeBox.visible = visible;
      } else if (selectedSceneNode.type === 'tee') {
        sceneConfig.teeBox.tee.visible = visible;
      } else if (selectedSceneNode.type === 'prop') {
        const prop = sceneConfig.props.find(p => p.id === selectedSceneNode.id);
        if (prop) prop.visible = visible;
      }

      // Update 3D proxy object visibility
      const proxyObj = sceneObjects.get(selectedSceneNode.id);
      if (proxyObj) {
        proxyObj.visible = visible;
      }

      renderSceneTree();
      broadcastSceneConfig();
    };

    // Gizmo mode controls
    window.setGizmoMode = function(mode) {
      currentGizmoMode = mode;
      document.getElementById('gizmoTranslate').classList.toggle('active', mode === 'translate');
      document.getElementById('gizmoRotate').classList.toggle('active', mode === 'rotate');
      document.getElementById('gizmoScale').classList.toggle('active', mode === 'scale');
      if (transformControls) {
        transformControls.setMode(mode);
      }
    };

    window.setGizmoSpace = function(space) {
      currentGizmoSpace = space;
      document.getElementById('gizmoWorld').classList.toggle('active', space === 'world');
      document.getElementById('gizmoLocal').classList.toggle('active', space === 'local');
      if (transformControls) {
        transformControls.setSpace(space);
      }
    };

    // ==================== SCENE FILE MANAGEMENT ====================

    // Scene file IndexedDB helpers
    async function saveSceneFileHandle(handle, fileName) {
      const db = await openFileHandleDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(FILE_HANDLE_STORE_NAME, 'readwrite');
        const store = tx.objectStore(FILE_HANDLE_STORE_NAME);
        store.put({ handle, fileName }, SCENE_FILE_HANDLE_KEY);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    async function loadSceneFileHandle() {
      const db = await openFileHandleDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(FILE_HANDLE_STORE_NAME, 'readonly');
        const store = tx.objectStore(FILE_HANDLE_STORE_NAME);
        const request = store.get(SCENE_FILE_HANDLE_KEY);
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    async function clearSceneFileHandle() {
      const db = await openFileHandleDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(FILE_HANDLE_STORE_NAME, 'readwrite');
        const store = tx.objectStore(FILE_HANDLE_STORE_NAME);
        store.delete(SCENE_FILE_HANDLE_KEY);
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
      });
    }

    // Update scene file status UI
    function updateSceneFileStatusUI() {
      const fileStatus = document.getElementById('sceneFileStatus');
      if (sceneFileHandle && sceneFilePath) {
        fileStatus.textContent = sceneFilePath;
        fileStatus.title = sceneFilePath;
      } else {
        fileStatus.textContent = 'No scene file linked';
        fileStatus.title = '';
      }
    }

    // New scene
    window.handleNewScene = function() {
      sceneConfig = JSON.parse(JSON.stringify(DEFAULT_SCENE_CONFIG));
      sceneFileHandle = null;
      sceneFilePath = null;
      clearSceneFileHandle();
      selectedSceneNode = null;

      document.getElementById('sceneNameInput').value = sceneConfig.name;
      renderSceneTree();
      updateSceneFileStatusUI();
      showTransformControls(false);
      createSceneProxyObjects();
      if (transformControls) {
        transformControls.detach();
        transformControls.visible = false;
      }

      // Update character position based on new tee position
      updateCharacterPosition();
      updateVideoBillboard();

      broadcastSceneConfig();
      showStatus('New scene created', 'saved');
    };

    // Open scene file
    window.handleOpenScene = async function() {
      try {
        const [handle] = await window.showOpenFilePicker({
          types: [{
            description: 'Scene JSON',
            accept: { 'application/json': ['.json', '.scene'] }
          }],
          multiple: false
        });

        sceneFileHandle = handle;
        sceneFilePath = handle.name;
        await saveSceneFileHandle(handle, handle.name);

        const file = await handle.getFile();
        const text = await file.text();
        const data = JSON.parse(text);

        if (data?.version && data?.terrain && data?.splat) {
          // Merge with defaults to ensure all required fields exist
          sceneConfig = {
            ...DEFAULT_SCENE_CONFIG,
            ...data,
            terrain: { ...DEFAULT_SCENE_CONFIG.terrain, ...data.terrain },
            splat: { ...DEFAULT_SCENE_CONFIG.splat, ...data.splat },
            teeBox: {
              ...DEFAULT_SCENE_CONFIG.teeBox,
              ...(data.teeBox || {}),
              tee: { ...DEFAULT_SCENE_CONFIG.teeBox.tee, ...(data.teeBox?.tee || {}) },
            },
            props: data.props || [],
          };
          document.getElementById('sceneNameInput').value = sceneConfig.name || 'Untitled';
          selectedSceneNode = null;
          renderSceneTree();
          updateSceneFileStatusUI();
          showTransformControls(false);
          createSceneProxyObjects();
          if (transformControls) {
            transformControls.detach();
            transformControls.visible = false;
          }

          // Update actual 3D meshes to match loaded scene config
          applySceneConfigToMeshes();

          broadcastSceneConfig();
          showStatus('Scene loaded: ' + sceneFilePath, 'saved');
        } else {
          showStatus('Invalid scene file format', 'ready');
        }
      } catch (e) {
        if (e.name !== 'AbortError') {
          console.error('Failed to open scene file:', e);
          showStatus('Failed to open scene file', 'ready');
        }
      }
    };

    // Save scene file
    window.handleSaveScene = async function() {
      // Update scene name from input
      sceneConfig.name = document.getElementById('sceneNameInput').value || 'Untitled Scene';

      if (!sceneFileHandle) {
        // No file linked, prompt to save as new file
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: sceneConfig.name.toLowerCase().replace(/\s+/g, '-') + '.scene.json',
            types: [{
              description: 'Scene JSON',
              accept: { 'application/json': ['.json'] }
            }]
          });

          sceneFileHandle = handle;
          sceneFilePath = handle.name;
          await saveSceneFileHandle(handle, handle.name);
        } catch (e) {
          if (e.name !== 'AbortError') {
            console.error('Failed to save scene file:', e);
            showStatus('Failed to save scene file', 'ready');
          }
          return;
        }
      }

      try {
        const hasPermission = await verifyFilePermission(sceneFileHandle);
        if (!hasPermission) {
          showStatus('Permission denied', 'ready');
          return;
        }

        const writable = await sceneFileHandle.createWritable();
        const json = JSON.stringify(sceneConfig, null, 2);
        await writable.write(json);
        await writable.close();

        updateSceneFileStatusUI();
        broadcastSceneConfig();
        showStatus('Scene saved: ' + sceneFilePath, 'saved');
      } catch (e) {
        console.error('Failed to write scene file:', e);
        showStatus('Failed to save: ' + e.message, 'ready');
      }
    };

    // Try to restore scene file handle on load
    // Only queries permission (no request) since user activation is required for requestPermission
    async function tryRestoreSceneFileHandle() {
      try {
        const stored = await loadSceneFileHandle();
        if (stored?.handle) {
          // Only query, don't request - requestPermission requires user activation
          const permission = await stored.handle.queryPermission({ mode: 'read' });
          if (permission === 'granted') {
            sceneFileHandle = stored.handle;
            sceneFilePath = stored.fileName;

            // Load the scene file
            const file = await sceneFileHandle.getFile();
            const text = await file.text();
            const data = JSON.parse(text);

            if (data?.version && data?.terrain && data?.splat) {
              // Merge with defaults to ensure all required fields exist (same as handleOpenScene)
              sceneConfig = {
                ...DEFAULT_SCENE_CONFIG,
                ...data,
                terrain: { ...DEFAULT_SCENE_CONFIG.terrain, ...data.terrain },
                splat: { ...DEFAULT_SCENE_CONFIG.splat, ...data.splat },
                teeBox: {
                  ...DEFAULT_SCENE_CONFIG.teeBox,
                  ...(data.teeBox || {}),
                  tee: { ...DEFAULT_SCENE_CONFIG.teeBox.tee, ...(data.teeBox?.tee || {}) },
                },
                props: data.props || [],
              };
            }
          } else {
            // Store handle for later - will request permission on user action
            sceneFileHandle = stored.handle;
            sceneFilePath = stored.fileName;
          }
        }
      } catch (e) {
        console.warn('Failed to restore scene file handle:', e);
      }
    }

    // ==================== PROPS MANAGEMENT ====================

    // Show add prop dialog
    window.showAddPropDialog = function() {
      document.getElementById('addPropOverlay').classList.add('active');
      document.getElementById('newPropName').value = '';
      document.getElementById('selectedPropUrl').value = '';

      // Render mesh library grid
      const container = document.getElementById('propMeshGrid');
      const meshes = ASSET_LIBRARY.mesh || [];

      if (meshes.length === 0) {
        container.innerHTML = '<p style="font-size: 11px; color: #666; text-align: center; padding: 10px;">No meshes available</p>';
        return;
      }

      let html = '';
      meshes.forEach(mesh => {
        html += `
          <div class="model-item" onclick="selectPropMesh('${mesh.url}', '${mesh.name}', this)" title="${mesh.url}">
            <div class="model-name">${mesh.name}</div>
          </div>
        `;
      });
      container.innerHTML = html;
    };

    // Select mesh in add prop dialog
    window.selectPropMesh = function(url, name, element) {
      // Update hidden input
      document.getElementById('selectedPropUrl').value = url;

      // Update name if empty
      const nameInput = document.getElementById('newPropName');
      if (!nameInput.value.trim()) {
        nameInput.value = name;
      }

      // Update selection UI
      const items = document.querySelectorAll('#propMeshGrid .model-item');
      items.forEach(item => item.classList.remove('selected'));
      element.classList.add('selected');
    };

    // Hide add prop dialog
    window.hideAddPropDialog = function() {
      document.getElementById('addPropOverlay').classList.remove('active');
    };

    // Add new prop
    window.addNewProp = function() {
      const url = document.getElementById('selectedPropUrl').value.trim();
      let name = document.getElementById('newPropName').value.trim();

      if (!url) {
        showStatus('Please select a mesh', 'ready');
        return;
      }

      // Use mesh filename as default name if not provided
      if (!name) {
        name = url.split('/').pop().replace(/\.[^.]+$/, '');
      }

      const id = 'prop-' + Date.now().toString(36) + '-' + Math.random().toString(36).substring(2, 7);

      const newProp = {
        id,
        name,
        url,
        position: { x: 0, y: 0, z: 0 },
        rotation: { x: 0, y: 0, z: 0 },
        scale: { x: 1, y: 1, z: 1 },
        visible: true,
      };

      sceneConfig.props.push(newProp);
      hideAddPropDialog();
      renderSceneTree();

      // Create mesh for the new prop (loads GLB model)
      const propMesh = createPropMesh(newProp);
      if (propMesh) {
        sceneObjects.set(id, propMesh);
        scene.add(propMesh);
      }

      broadcastSceneConfig();
      showStatus('Prop added: ' + name, 'saved');

      // Select the new prop
      selectSceneNode('prop', id);
    };

    // Delete selected node
    window.deleteSelectedNode = function() {
      if (!selectedSceneNode) {
        showStatus('No object selected', 'ready');
        return;
      }

      // Only props can be deleted
      if (selectedSceneNode.type !== 'prop') {
        showStatus('Only props can be deleted', 'ready');
        return;
      }

      const index = sceneConfig.props.findIndex(p => p.id === selectedSceneNode.id);
      if (index !== -1) {
        const name = sceneConfig.props[index].name;
        const propId = sceneConfig.props[index].id;

        // Remove proxy object from scene
        const proxyObj = sceneObjects.get(propId);
        if (proxyObj) {
          scene.remove(proxyObj);
          sceneObjects.delete(propId);
        }

        // Detach gizmo
        if (transformControls) {
          transformControls.detach();
          transformControls.visible = false;
        }

        sceneConfig.props.splice(index, 1);
        selectedSceneNode = null;
        renderSceneTree();
        showTransformControls(false);
        broadcastSceneConfig();
        showStatus('Deleted: ' + name, 'saved');
      }
    };

    // Broadcast scene config to game
    function broadcastSceneConfig() {
      if (sceneChannel && sceneConfig) {
        console.log('[golf_editor] Broadcasting scene config:', {
          name: sceneConfig.name,
          terrain: sceneConfig.terrain,
          splat: sceneConfig.splat,
          teeBox: sceneConfig.teeBox,
          propsCount: sceneConfig.props?.length ?? 0
        });
        sceneChannel.postMessage({ type: 'scene', scene: sceneConfig });
      }
    }

    // ==================== SCENE 3D OBJECT RENDERING ====================

    // Create proxy objects for scene elements that can be selected with gizmo
    function createSceneProxyObjects() {
      // Clear existing proxy objects
      sceneObjects.forEach((obj, id) => {
        scene.remove(obj);
      });
      sceneObjects.clear();

      if (!sceneConfig) return;

      // Create terrain proxy (visible box representing terrain bounds)
      const terrainProxy = createProxyBox(
        sceneConfig.terrain,
        0x4ade80,
        { width: 150, height: 1, depth: 200 }
      );
      if (terrainProxy) {
        sceneObjects.set(sceneConfig.terrain.id, terrainProxy);
        scene.add(terrainProxy);
      }

      // Create splat proxy (visible sphere representing splat center)
      const splatProxy = createProxySphere(sceneConfig.splat, 0x60a5fa, 2);
      if (splatProxy) {
        sceneObjects.set(sceneConfig.splat.id, splatProxy);
        scene.add(splatProxy);
      }

      // Create tee box proxy (visible marker)
      const teeBoxProxy = createProxyMarker(sceneConfig.teeBox, 0xfbbf24);
      if (teeBoxProxy) {
        sceneObjects.set(sceneConfig.teeBox.id, teeBoxProxy);
        scene.add(teeBoxProxy);
      }

      // Create tee proxy (child of teeBox)
      if (sceneConfig.teeBox.tee) {
        const teeProxy = createTeeProxy(sceneConfig.teeBox, sceneConfig.teeBox.tee, 0xf59e0b);
        if (teeProxy) {
          sceneObjects.set(sceneConfig.teeBox.tee.id, teeProxy);
          scene.add(teeProxy);
        }
      }

      // Create character proxy (positioned relative to tee)
      createCharacterProxy();

      // Create prop meshes (load GLB models)
      sceneConfig.props.forEach(prop => {
        const propMesh = createPropMesh(prop);
        if (propMesh) {
          sceneObjects.set(prop.id, propMesh);
          scene.add(propMesh);
        }
      });
    }

    // Create a box proxy for terrain/props
    function createProxyBox(node, color, size) {
      if (!node) return null;

      const geometry = new THREE.BoxGeometry(size.width, size.height, size.depth);
      const material = new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0,  // Invisible proxy - only gizmo will show
        wireframe: true,
      });
      const mesh = new THREE.Mesh(geometry, material);

      mesh.position.set(
        node.position?.x ?? 0,
        node.position?.y ?? 0,
        node.position?.z ?? 0
      );

      if (node.rotation) {
        mesh.rotation.set(
          (node.rotation.x ?? 0) * DEG_TO_RAD,
          (node.rotation.y ?? 0) * DEG_TO_RAD,
          (node.rotation.z ?? 0) * DEG_TO_RAD
        );
      }

      if (node.scale !== undefined) {
        if (typeof node.scale === 'number') {
          mesh.scale.setScalar(node.scale);
        } else {
          mesh.scale.set(
            node.scale?.x ?? 1,
            node.scale?.y ?? 1,
            node.scale?.z ?? 1
          );
        }
      }

      mesh.visible = node.visible !== false;
      mesh.userData = { nodeId: node.id, nodeType: getNodeType(node.id) };

      return mesh;
    }

    // Create a sphere proxy for splat
    function createProxySphere(node, color, radius) {
      if (!node) return null;

      const geometry = new THREE.SphereGeometry(radius, 16, 16);
      const material = new THREE.MeshBasicMaterial({
        color,
        transparent: true,
        opacity: 0,  // Invisible proxy - only gizmo will show
        wireframe: true,
      });
      const mesh = new THREE.Mesh(geometry, material);

      mesh.position.set(
        node.position?.x ?? 0,
        node.position?.y ?? 0,
        node.position?.z ?? 0
      );

      if (node.rotation) {
        mesh.rotation.set(
          (node.rotation.x ?? 0) * DEG_TO_RAD,
          (node.rotation.y ?? 0) * DEG_TO_RAD,
          (node.rotation.z ?? 0) * DEG_TO_RAD
        );
      }

      if (node.scale !== undefined) {
        mesh.scale.setScalar(typeof node.scale === 'number' ? node.scale : 1);
      }

      mesh.visible = node.visible !== false;
      mesh.userData = { nodeId: node.id, nodeType: 'splat' };

      return mesh;
    }

    // Create a prop mesh by loading the GLB model
    function createPropMesh(node) {
      if (!node || !node.url) return null;

      const group = new THREE.Group();

      // Set initial transform
      group.position.set(
        node.position?.x ?? 0,
        node.position?.y ?? 0,
        node.position?.z ?? 0
      );

      if (node.rotation) {
        group.rotation.set(
          (node.rotation.x ?? 0) * DEG_TO_RAD,
          (node.rotation.y ?? 0) * DEG_TO_RAD,
          (node.rotation.z ?? 0) * DEG_TO_RAD
        );
      }

      // Props use Vector3 scale
      if (node.scale) {
        if (typeof node.scale === 'number') {
          group.scale.setScalar(node.scale);
        } else {
          group.scale.set(
            node.scale?.x ?? 1,
            node.scale?.y ?? 1,
            node.scale?.z ?? 1
          );
        }
      }

      group.visible = node.visible !== false;
      group.userData = { nodeId: node.id, nodeType: 'prop' };

      // Load the GLB model
      const loader = new GLTFLoader();
      loader.load(
        node.url,
        (gltf) => {
          const model = gltf.scene;
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          group.add(model);
          console.log('Prop model loaded:', node.url);
        },
        undefined,
        (error) => {
          console.error('Failed to load prop model:', error);
          // Fallback: create a simple box if GLB fails to load
          const boxGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
          const boxMaterial = new THREE.MeshBasicMaterial({
            color: 0xf472b6,
            transparent: true,
            opacity: 0.7,
          });
          const box = new THREE.Mesh(boxGeometry, boxMaterial);
          box.position.y = 0.25;
          group.add(box);
        }
      );

      return group;
    }

    // Create a tee box proxy by loading the GLB model
    function createProxyMarker(node, color) {
      if (!node) return null;

      const group = new THREE.Group();

      // Set initial transform
      group.position.set(
        node.position?.x ?? 0,
        node.position?.y ?? 0,
        node.position?.z ?? 0
      );

      if (node.rotation) {
        group.rotation.set(
          (node.rotation.x ?? 0) * DEG_TO_RAD,
          (node.rotation.y ?? 0) * DEG_TO_RAD,
          (node.rotation.z ?? 0) * DEG_TO_RAD
        );
      }

      const teeBoxScale = node.scale ?? 1;
      group.scale.set(teeBoxScale, teeBoxScale, teeBoxScale);
      group.visible = node.visible !== false;

      group.userData = { nodeId: node.id, nodeType: 'teeBox' };

      // Load the TeeBox GLB model
      const teeBoxUrl = node.url || './models/teebox/Teebox.glb';
      const loader = new GLTFLoader();
      loader.load(
        teeBoxUrl,
        (gltf) => {
          const model = gltf.scene;
          model.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });
          group.add(model);
          console.log('TeeBox model loaded:', teeBoxUrl);
        },
        undefined,
        (error) => {
          console.error('Failed to load TeeBox model:', error);
          // Fallback: create a simple marker if GLB fails to load
          const poleGeometry = new THREE.CylinderGeometry(0.05, 0.05, 2, 8);
          const poleMaterial = new THREE.MeshBasicMaterial({
            color,
            transparent: true,
            opacity: 0.7,
          });
          const pole = new THREE.Mesh(poleGeometry, poleMaterial);
          pole.position.y = 1;
          group.add(pole);
        }
      );

      return group;
    }

    // Create a tee proxy (small golf tee peg) - positioned relative to teeBox
    function createTeeProxy(teeBox, tee, color) {
      if (!tee) return null;

      const group = new THREE.Group();

      // Create golf tee shape using lathe geometry
      const points = [
        new THREE.Vector2(0.005, 0),     // Bottom point (spike)
        new THREE.Vector2(0.008, 0.02),  // Lower spike
        new THREE.Vector2(0.010, 0.04),  // Mid spike
        new THREE.Vector2(0.012, 0.06),  // Upper spike
        new THREE.Vector2(0.018, 0.07),  // Flare start
        new THREE.Vector2(0.025, 0.075), // Cup outer edge
        new THREE.Vector2(0.025, 0.08),  // Cup top outer
        new THREE.Vector2(0.018, 0.08),  // Cup top inner
      ];
      const teeGeometry = new THREE.LatheGeometry(points, 16);
      const teeMaterial = new THREE.MeshStandardMaterial({
        color: 0xd4a574,  // Wood/tan color
        roughness: 0.7,
        metalness: 0.1,
      });
      const teeMesh = new THREE.Mesh(teeGeometry, teeMaterial);
      teeMesh.castShadow = true;
      teeMesh.receiveShadow = true;
      group.add(teeMesh);

      // Calculate world position with hierarchical transform (parent rotation affects child position)
      const parentRot = new THREE.Euler(
        (teeBox.rotation?.x ?? 0) * DEG_TO_RAD,
        (teeBox.rotation?.y ?? 0) * DEG_TO_RAD,
        (teeBox.rotation?.z ?? 0) * DEG_TO_RAD
      );
      const childRelPos = new THREE.Vector3(
        tee.position?.x ?? 0,
        tee.position?.y ?? 0,
        tee.position?.z ?? 0
      );
      childRelPos.applyEuler(parentRot);
      group.position.set(
        (teeBox.position?.x ?? 0) + childRelPos.x,
        (teeBox.position?.y ?? 0) + childRelPos.y,
        (teeBox.position?.z ?? 0) + childRelPos.z
      );

      if (tee.rotation) {
        group.rotation.set(
          (tee.rotation.x ?? 0) * DEG_TO_RAD,
          (tee.rotation.y ?? 0) * DEG_TO_RAD,
          (tee.rotation.z ?? 0) * DEG_TO_RAD
        );
      }

      const teeScale = tee.scale ?? 1;
      group.scale.set(teeScale, teeScale, teeScale);
      group.visible = tee.visible !== false;

      group.userData = { nodeId: tee.id, nodeType: 'tee' };

      return group;
    }

    // Get character offset from motion config
    function getCharacterOffset() {
      if (isVideoCharacter(currentCharacter)) {
        const videoConfig = config?.video?.[currentCharacter];
        return videoConfig?.offset ?? { x: 0, y: 0, z: 0 };
      } else {
        const charConfig = config?.characters?.[currentCharacter];
        return charConfig?.position ?? { x: 0, y: 0, z: 0 };
      }
    }

    // Character proxy functions (no-op, actual character moves with tee)
    function createCharacterProxy() {
      // No visual proxy needed - actual character moves with tee
    }

    function updateCharacterProxy() {
      // No visual proxy needed - actual character moves with tee
    }

    // Get node type from ID
    function getNodeType(id) {
      if (!sceneConfig) return 'unknown';
      if (sceneConfig.terrain.id === id) return 'terrain';
      if (sceneConfig.splat.id === id) return 'splat';
      if (sceneConfig.teeBox.id === id) return 'teeBox';
      if (sceneConfig.teeBox.tee?.id === id) return 'tee';
      if (sceneConfig.props.some(p => p.id === id)) return 'prop';
      return 'unknown';
    }

    // Update scene proxy object positions from config
    function updateSceneProxyObjects() {
      if (!sceneConfig) return;

      // Update terrain proxy
      const terrainObj = sceneObjects.get(sceneConfig.terrain.id);
      if (terrainObj) {
        updateProxyFromNode(terrainObj, sceneConfig.terrain);
      }

      // Update splat proxy
      const splatObj = sceneObjects.get(sceneConfig.splat.id);
      if (splatObj) {
        updateProxyFromNode(splatObj, sceneConfig.splat);
      }

      // Update tee box proxy
      const teeBoxObj = sceneObjects.get(sceneConfig.teeBox.id);
      if (teeBoxObj) {
        updateProxyFromNode(teeBoxObj, sceneConfig.teeBox);
      }

      // Update tee proxy (child of teeBox, needs hierarchical transform)
      if (sceneConfig.teeBox.tee) {
        const teeObj = sceneObjects.get(sceneConfig.teeBox.tee.id);
        if (teeObj) {
          const teeBox = sceneConfig.teeBox;
          const tee = teeBox.tee;
          // Apply parent rotation to child's relative position (hierarchical transform)
          const parentRot = new THREE.Euler(
            (teeBox.rotation?.x ?? 0) * DEG_TO_RAD,
            (teeBox.rotation?.y ?? 0) * DEG_TO_RAD,
            (teeBox.rotation?.z ?? 0) * DEG_TO_RAD
          );
          const childRelPos = new THREE.Vector3(
            tee.position?.x ?? 0,
            tee.position?.y ?? 0,
            tee.position?.z ?? 0
          );
          childRelPos.applyEuler(parentRot);
          teeObj.position.set(
            (teeBox.position?.x ?? 0) + childRelPos.x,
            (teeBox.position?.y ?? 0) + childRelPos.y,
            (teeBox.position?.z ?? 0) + childRelPos.z
          );
          if (tee.rotation) {
            teeObj.rotation.set(
              (tee.rotation.x ?? 0) * DEG_TO_RAD,
              (tee.rotation.y ?? 0) * DEG_TO_RAD,
              (tee.rotation.z ?? 0) * DEG_TO_RAD
            );
          }
          const teeScale = tee.scale ?? 1;
          teeObj.scale.set(teeScale, teeScale, teeScale);
          teeObj.visible = tee.visible !== false;
        }
      }

      // Update prop proxies
      sceneConfig.props.forEach(prop => {
        const propObj = sceneObjects.get(prop.id);
        if (propObj) {
          updateProxyFromNode(propObj, prop);
        }
      });

      // Update character proxy and actual character position
      updateCharacterProxy();
      updateCharacterPosition();
      updateVideoBillboard();
    }

    // Update a proxy object from node config
    function updateProxyFromNode(obj, node) {
      if (!obj || !node) return;

      obj.position.set(
        node.position?.x ?? 0,
        node.position?.y ?? 0,
        node.position?.z ?? 0
      );

      if (node.rotation) {
        obj.rotation.set(
          (node.rotation.x ?? 0) * DEG_TO_RAD,
          (node.rotation.y ?? 0) * DEG_TO_RAD,
          (node.rotation.z ?? 0) * DEG_TO_RAD
        );
      }

      if (node.scale !== undefined) {
        if (typeof node.scale === 'number') {
          obj.scale.setScalar(node.scale);
        } else {
          obj.scale.set(
            node.scale?.x ?? 1,
            node.scale?.y ?? 1,
            node.scale?.z ?? 1
          );
        }
      }

      if (node.visible !== undefined) {
        obj.visible = node.visible;
      }
    }

    // Click to select scene objects
    function setupSceneClickSelection() {
      const canvas = document.getElementById('canvas');
      if (!canvas) return;

      canvas.addEventListener('click', (event) => {
        if (editorMode !== 'scene' || !sceneConfig) return;
        if (isDragging) return; // Don't select while dragging

        // Check if clicking on gizmo
        if (transformControls && transformControls.dragging) return;

        const rect = canvas.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        if (!raycaster) raycaster = new THREE.Raycaster();
        if (!mouse) mouse = new THREE.Vector2();

        mouse.set(x, y);
        raycaster.setFromCamera(mouse, camera);

        // Get all scene objects
        const selectableObjects = Array.from(sceneObjects.values());
        const intersects = raycaster.intersectObjects(selectableObjects, true);

        if (intersects.length > 0) {
          // Find the root object with userData
          let selectedObj = intersects[0].object;
          while (selectedObj.parent && !selectedObj.userData?.nodeId) {
            selectedObj = selectedObj.parent;
          }

          if (selectedObj.userData?.nodeId) {
            const nodeId = selectedObj.userData.nodeId;
            const nodeType = selectedObj.userData.nodeType;
            selectSceneNode(nodeType, nodeId);
          }
        } else {
          // Deselect when clicking on empty space
          selectedSceneNode = null;
          renderSceneTree();
          showTransformControls(false);
          if (transformControls) {
            transformControls.detach();
            transformControls.visible = false;
          }
        }
      });

      // ESC key to deselect
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && editorMode === 'scene') {
          selectedSceneNode = null;
          renderSceneTree();
          showTransformControls(false);
          if (transformControls) {
            transformControls.detach();
            transformControls.visible = false;
          }
        }

        // Delete key to delete selected prop
        if (event.key === 'Delete' && editorMode === 'scene' && selectedSceneNode?.type === 'prop') {
          deleteSelectedNode();
        }
      });
    }

    // Initialize scene 3D rendering when entering scene mode
    function initSceneEditorRendering() {
      createSceneProxyObjects();
      setupSceneClickSelection();
    }

    // Start
    init();
  </script>
</body>
</html>
