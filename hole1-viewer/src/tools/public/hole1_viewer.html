<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hole 1 Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #config {
            display: none;
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            min-width: 250px;
        }
        #config.visible { display: block; }
        #config h3 { margin: 0 0 10px 0; color: #4CAF50; }
        #config label { display: block; margin: 8px 0 4px 0; color: #aaa; }
        #config input[type="range"] { width: 100%; }
        #config .value { float: right; color: #4CAF50; }
        #config button {
            margin-top: 10px;
            padding: 8px 16px;
            background: #4CAF50;
            border: none;
            color: #fff;
            cursor: pointer;
            border-radius: 4px;
            margin-right: 5px;
        }
        #config button:hover { background: #45a049; }
        #config .hint { color: #666; font-size: 10px; margin-top: 10px; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<div id="config">
    <h3>Terrain Config (~)</h3>
    <label>Terrain Size <span class="value" id="val-terrainSize">512</span></label>
    <input type="range" id="terrainSize" min="128" max="1024" step="64" value="512">
    <label>Segments <span class="value" id="val-segments">256</span></label>
    <input type="range" id="segments" min="32" max="512" step="32" value="256">
    <label>Height Scale <span class="value" id="val-heightScale">50</span></label>
    <input type="range" id="heightScale" min="0" max="150" step="5" value="50">
    <label>Tree Width <span class="value" id="val-treeWidth">10</span></label>
    <input type="range" id="treeWidth" min="5" max="30" step="1" value="10">
    <label>Stripe Width <span class="value" id="val-stripeWidth">8</span></label>
    <input type="range" id="stripeWidth" min="2" max="20" step="1" value="8">
    <label>Crosshatch Density <span class="value" id="val-crosshatchDensity">12</span></label>
    <input type="range" id="crosshatchDensity" min="4" max="30" step="1" value="12">
    <label>Ring Spacing <span class="value" id="val-ringSpacing">3</span></label>
    <input type="range" id="ringSpacing" min="1" max="10" step="0.5" value="3">
    <button id="applyBtn">Apply</button>
    <button id="saveBtn">Save Data</button>
    <button id="loadBtn">Load Data</button>
    <div class="hint">Press ~ to toggle this panel</div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- CONFIGURATION (editable via UI) ---
    const config = {
        terrainSize: 512,
        segments: 256,
        heightScale: 50,
        treeWidth: 10,
        stripeWidth: 8,
        crosshatchDensity: 12,
        ringSpacing: 3,
    };

    // --- TERRAIN SHADER ---
    const terrainVertexShader = `
        varying vec2 vUv;
        varying vec3 vWorldPos;

        void main() {
            vUv = uv;
            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
            vWorldPos = worldPosition.xyz;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    const terrainFragmentShader = `
        uniform sampler2D surfaceMap;
        uniform vec2 teePos;
        uniform vec2 holePos;
        uniform float terrainSize;
        uniform float stripeFreq;
        uniform float crosshatchFreq;
        uniform float ringFreq;

        varying vec2 vUv;
        varying vec3 vWorldPos;

        // Cartoon green color palette
        const vec3 fairwayLight = vec3(0.45, 0.75, 0.35);
        const vec3 fairwayDark = vec3(0.35, 0.65, 0.28);
        const vec3 roughLight = vec3(0.35, 0.55, 0.25);
        const vec3 roughDark = vec3(0.28, 0.45, 0.20);
        const vec3 greenLight = vec3(0.40, 0.70, 0.35);
        const vec3 greenDark = vec3(0.32, 0.62, 0.28);
        const vec3 teeColor = vec3(0.42, 0.72, 0.38);
        const vec3 forestColor = vec3(0.20, 0.35, 0.15);
        const vec3 sandLight = vec3(0.96, 0.87, 0.70);   // Light tan
        const vec3 sandDark = vec3(0.85, 0.75, 0.55);    // Darker tan

        bool isColorMatch(vec3 c1, vec3 c2, float tolerance) {
            return distance(c1, c2) < tolerance;
        }

        void main() {
            vec4 surfaceColor = texture2D(surfaceMap, vUv);
            vec3 sc = surfaceColor.rgb;

            vec3 color = forestColor; // default fallback

            // Detect terrain type by color matching
            bool isFairway = isColorMatch(sc, vec3(1.0, 1.0, 0.0), 0.2);       // Yellow
            bool isRough = isColorMatch(sc, vec3(0.5, 0.5, 0.5), 0.2);          // Gray
            bool isGreen = isColorMatch(sc, vec3(0.0, 1.0, 1.0), 0.2);          // Cyan
            bool isTee = isColorMatch(sc, vec3(1.0, 0.0, 1.0), 0.2);            // Magenta
            bool isSand = isColorMatch(sc, vec3(0.0, 0.0, 1.0), 0.2);           // Blue

            // World position for patterns (xz plane after rotation)
            vec2 worldXZ = vWorldPos.xz;

            if (isFairway) {
                // Stripes aligned with tee->hole direction
                vec2 teeWorld = (teePos - 0.5) * terrainSize;
                vec2 holeWorld = (holePos - 0.5) * terrainSize;
                vec2 dir = normalize(holeWorld - teeWorld);
                vec2 perp = vec2(-dir.y, dir.x); // perpendicular to direction
                float stripe = sin(dot(worldXZ, perp) * stripeFreq);
                color = mix(fairwayDark, fairwayLight, step(0.0, stripe));
            }
            else if (isRough) {
                // Crosshatch pattern
                float hatch1 = sin((worldXZ.x + worldXZ.y) * crosshatchFreq);
                float hatch2 = sin((worldXZ.x - worldXZ.y) * crosshatchFreq);
                float pattern = hatch1 * hatch2;
                color = mix(roughDark, roughLight, step(0.0, pattern));
            }
            else if (isGreen) {
                // Concentric rings from hole
                vec2 holeWorld = (holePos - 0.5) * terrainSize;
                float dist = distance(worldXZ, holeWorld);
                float ring = sin(dist * ringFreq);
                color = mix(greenDark, greenLight, step(0.0, ring));
            }
            else if (isTee) {
                // Solid tee color with subtle stripe aligned to fairway
                vec2 teeWorld = (teePos - 0.5) * terrainSize;
                vec2 holeWorld = (holePos - 0.5) * terrainSize;
                vec2 dir = normalize(holeWorld - teeWorld);
                vec2 perp = vec2(-dir.y, dir.x);
                float stripe = sin(dot(worldXZ, perp) * stripeFreq * 2.0);
                color = mix(teeColor * 0.95, teeColor, step(0.0, stripe));
            }
            else if (isSand) {
                // Sand bunker with subtle wavy pattern
                float wave1 = sin(worldXZ.x * 0.8 + worldXZ.y * 0.3);
                float wave2 = sin(worldXZ.x * 0.3 - worldXZ.y * 0.8);
                float pattern = wave1 * wave2;
                color = mix(sandDark, sandLight, smoothstep(-0.5, 0.5, pattern));
            }

            gl_FragColor = vec4(color, 1.0);
        }
    `;

    // Terrain material reference for uniform updates
    let terrainMaterial = null;

    const ASSETS_PATH = '/assets/hole1';
    const CUBEMAP_PATH = '/assets/nycriver';

    // --- SCENE SETUP ---
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.position.set(0, 150, 300);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.sortObjects = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.target.set(0, 0, 0);

    // --- GROUPS ---
    const forestGroup = new THREE.Group();
    scene.add(forestGroup);

    // --- LOADERS ---
    const textureLoader = new THREE.TextureLoader();
    const cubeTextureLoader = new THREE.CubeTextureLoader();

    // --- LOAD CUBEMAP SKYBOX ---
    const skybox = cubeTextureLoader
        .setPath(CUBEMAP_PATH + '/')
        .load(['px.jpg', 'nx.jpg', 'py.jpg', 'ny.jpg', 'pz.jpg', 'nz.jpg']);
    scene.background = skybox;

    // --- PRE-LOAD TREE TEXTURES ---
    const treeTextures = [
        textureLoader.load(`${ASSETS_PATH}/trees/1.png`),
        textureLoader.load(`${ASSETS_PATH}/trees/2.png`),
        textureLoader.load(`${ASSETS_PATH}/trees/3.png`),
        textureLoader.load(`${ASSETS_PATH}/trees/4.png`),
    ];

    // --- LOAD TERRAIN TEXTURES ---
    const surfaceMap = textureLoader.load(`${ASSETS_PATH}/surface.png`);
    surfaceMap.colorSpace = THREE.SRGBColorSpace;

    // --- HEIGHT DATA ---
    let heightData = null;
    let heightCanvas = null;
    let heightWidth = 0;
    let heightHeight = 0;

    function loadHeightData() {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                heightCanvas = document.createElement('canvas');
                heightCanvas.width = img.width;
                heightCanvas.height = img.height;
                heightWidth = img.width;
                heightHeight = img.height;
                const ctx = heightCanvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                heightData = ctx.getImageData(0, 0, img.width, img.height).data;
                resolve();
            };
            img.src = `${ASSETS_PATH}/height.png`;
        });
    }

    function sampleHeight(u, v) {
        if (!heightData) return 0;
        const px = Math.floor(u * heightWidth);
        const py = Math.floor(v * heightHeight);
        if (px < 0 || px >= heightWidth || py < 0 || py >= heightHeight) return 0;
        const idx = (py * heightWidth + px) * 4;
        return heightData[idx] / 255;
    }

    // --- TERRAIN ---
    let terrain = null;

    function createTerrain() {
        if (terrain) {
            scene.remove(terrain);
            terrain.geometry.dispose();
            terrain.material.dispose();
        }

        const geometry = new THREE.PlaneGeometry(
            config.terrainSize,
            config.terrainSize,
            config.segments,
            config.segments
        );

        // Bake height into geometry vertices
        const pos = geometry.attributes.position;
        const uv = geometry.attributes.uv;
        for (let i = 0; i < pos.count; i++) {
            const u = uv.getX(i);
            const v = uv.getY(i);
            const h = sampleHeight(u, 1 - v) * config.heightScale;
            pos.setZ(i, h);
        }
        pos.needsUpdate = true;
        geometry.computeVertexNormals();

        terrainMaterial = new THREE.ShaderMaterial({
            uniforms: {
                surfaceMap: { value: surfaceMap },
                teePos: { value: new THREE.Vector2(0.5, 0.5) },
                holePos: { value: new THREE.Vector2(0.5, 0.5) },
                terrainSize: { value: config.terrainSize },
                stripeFreq: { value: 2.0 * Math.PI / config.stripeWidth },
                crosshatchFreq: { value: 2.0 * Math.PI / config.crosshatchDensity },
                ringFreq: { value: 2.0 * Math.PI / config.ringSpacing },
            },
            vertexShader: terrainVertexShader,
            fragmentShader: terrainFragmentShader,
        });

        terrain = new THREE.Mesh(geometry, terrainMaterial);
        terrain.rotation.x = -Math.PI / 2;
        terrain.position.y = 0;
        scene.add(terrain);
    }

    function getHeightAt(x, z) {
        if (!heightData) return 0;

        // Convert world coords to UV (0-1 range)
        const u = (x / config.terrainSize + 0.5);
        const v = (z / config.terrainSize + 0.5);

        // Sample heightmap - terrain uses (1-v) in sampleHeight call,
        // but rotation flips Z, so trees use v directly to match
        const px = Math.floor(u * heightWidth);
        const py = Math.floor(v * heightHeight);

        if (px < 0 || px >= heightWidth || py < 0 || py >= heightHeight) {
            return 0;
        }

        const idx = (py * heightWidth + px) * 4;
        const heightValue = heightData[idx] / 255;
        return heightValue * config.heightScale;
    }

    // --- FOREST DATA ---
    let forestData = null;

    async function loadForestData() {
        await loadHeightData();

        const response = await fetch('/api/hole1/forest');
        forestData = await response.json();

        // Restore config values if they exist in the saved data
        if (forestData.config) {
            config.terrainSize = forestData.config.terrainSize ?? config.terrainSize;
            config.segments = forestData.config.segments ?? config.segments;
            config.heightScale = forestData.config.heightScale ?? config.heightScale;
            config.treeWidth = forestData.config.treeWidth ?? config.treeWidth;
            config.stripeWidth = forestData.config.stripeWidth ?? config.stripeWidth;
            config.crosshatchDensity = forestData.config.crosshatchDensity ?? config.crosshatchDensity;
            config.ringSpacing = forestData.config.ringSpacing ?? config.ringSpacing;

            // Update slider values and displays
            sliders.terrainSize.value = config.terrainSize;
            sliders.segments.value = config.segments;
            sliders.heightScale.value = config.heightScale;
            sliders.treeWidth.value = config.treeWidth;
            sliders.stripeWidth.value = config.stripeWidth;
            sliders.crosshatchDensity.value = config.crosshatchDensity;
            sliders.ringSpacing.value = config.ringSpacing;

            document.getElementById('val-terrainSize').textContent = config.terrainSize;
            document.getElementById('val-segments').textContent = config.segments;
            document.getElementById('val-heightScale').textContent = config.heightScale;
            document.getElementById('val-treeWidth').textContent = config.treeWidth;
            document.getElementById('val-stripeWidth').textContent = config.stripeWidth;
            document.getElementById('val-crosshatchDensity').textContent = config.crosshatchDensity;
            document.getElementById('val-ringSpacing').textContent = config.ringSpacing;
        }

        createTerrain();

        // Update shader uniforms with tee/hole positions
        if (terrainMaterial && forestData) {
            const imgWidth = forestData.width;
            const imgHeight = forestData.height;

            if (forestData.tee) {
                // Convert pixel coords to UV (0-1)
                const teeU = forestData.tee.x / imgWidth;
                const teeV = 1.0 - (forestData.tee.y / imgHeight); // flip Y
                terrainMaterial.uniforms.teePos.value.set(teeU, teeV);
            }

            if (forestData.hole) {
                const holeU = forestData.hole.x / imgWidth;
                const holeV = 1.0 - (forestData.hole.y / imgHeight); // flip Y
                terrainMaterial.uniforms.holePos.value.set(holeU, holeV);
            }

            // Apply shader pattern uniforms from config
            terrainMaterial.uniforms.stripeFreq.value = 2.0 * Math.PI / config.stripeWidth;
            terrainMaterial.uniforms.crosshatchFreq.value = 2.0 * Math.PI / config.crosshatchDensity;
            terrainMaterial.uniforms.ringFreq.value = 2.0 * Math.PI / config.ringSpacing;
        }

        rebuildTrees();
    }

    function rebuildTrees() {
        forestGroup.clear();
        if (!forestData) return;

        const cx = -forestData.width / 2;
        const cz = -forestData.height / 2;

        // --- TREES ---
        const treeHeight = config.treeWidth * (832 / 588);
        const planeGeo = new THREE.PlaneGeometry(config.treeWidth, treeHeight);

        forestData.trees.forEach(t => {
            const tex = treeTextures[Math.floor(Math.random() * treeTextures.length)];
            const mat = new THREE.MeshBasicMaterial({
                map: tex,
                transparent: true,
                alphaTest: 0.5,
                side: THREE.DoubleSide,
                depthWrite: false,
            });

            const worldX = t.x + cx;
            const worldZ = t.y + cz;
            const groundY = getHeightAt(worldX, worldZ);

            const mesh = new THREE.Mesh(planeGeo, mat);
            mesh.position.set(worldX, groundY + treeHeight / 2, worldZ);
            mesh.userData.isTree = true;
            forestGroup.add(mesh);
        });

        // --- HOLE (cyan cylinder + flag) ---
        if (forestData.hole) {
            const holeX = forestData.hole.x + cx;
            const holeZ = forestData.hole.y + cz;
            const holeY = getHeightAt(holeX, holeZ);

            // Hole cup (cylinder in ground)
            const cupGeo = new THREE.CylinderGeometry(2, 2, 1, 16);
            const cupMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const cup = new THREE.Mesh(cupGeo, cupMat);
            cup.position.set(holeX, holeY - 0.5, holeZ);
            forestGroup.add(cup);

            // Flag pole
            const poleGeo = new THREE.CylinderGeometry(0.2, 0.2, 15, 8);
            const poleMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const pole = new THREE.Mesh(poleGeo, poleMat);
            pole.position.set(holeX, holeY + 7.5, holeZ);
            forestGroup.add(pole);

            // Flag (triangle)
            const flagShape = new THREE.Shape();
            flagShape.moveTo(0, 0);
            flagShape.lineTo(6, -2);
            flagShape.lineTo(0, -4);
            flagShape.lineTo(0, 0);
            const flagGeo = new THREE.ShapeGeometry(flagShape);
            const flagMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
            const flag = new THREE.Mesh(flagGeo, flagMat);
            flag.position.set(holeX, holeY + 14, holeZ);
            flag.rotation.y = Math.PI / 4;
            forestGroup.add(flag);
        }

        // --- TEE (magenta platform + ball) ---
        if (forestData.tee) {
            const teeX = forestData.tee.x + cx;
            const teeZ = forestData.tee.y + cz;
            const teeY = getHeightAt(teeX, teeZ);

            // Tee platform
            const teeGeo = new THREE.BoxGeometry(8, 0.5, 4);
            const teeMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            const teeMesh = new THREE.Mesh(teeGeo, teeMat);
            teeMesh.position.set(teeX, teeY + 0.25, teeZ);
            forestGroup.add(teeMesh);

            // Golf ball on tee
            const ballGeo = new THREE.SphereGeometry(0.8, 16, 16);
            const ballMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const ball = new THREE.Mesh(ballGeo, ballMat);
            ball.position.set(teeX, teeY + 1.5, teeZ);
            forestGroup.add(ball);

            // Tee peg
            const pegGeo = new THREE.CylinderGeometry(0.15, 0.3, 1, 8);
            const pegMat = new THREE.MeshBasicMaterial({ color: 0xFFE4B5 });
            const peg = new THREE.Mesh(pegGeo, pegMat);
            peg.position.set(teeX, teeY + 0.75, teeZ);
            forestGroup.add(peg);
        }

        console.log(`Loaded ${forestData.trees.length} trees` +
            (forestData.hole ? `, hole at (${forestData.hole.x}, ${forestData.hole.y})` : '') +
            (forestData.tee ? `, tee at (${forestData.tee.x}, ${forestData.tee.y})` : ''));
    }

    loadForestData();

    // --- CONFIG UI ---
    const configPanel = document.getElementById('config');
    const sliders = {
        terrainSize: document.getElementById('terrainSize'),
        segments: document.getElementById('segments'),
        heightScale: document.getElementById('heightScale'),
        treeWidth: document.getElementById('treeWidth'),
        stripeWidth: document.getElementById('stripeWidth'),
        crosshatchDensity: document.getElementById('crosshatchDensity'),
        ringSpacing: document.getElementById('ringSpacing'),
    };

    // Update value displays
    Object.keys(sliders).forEach(key => {
        sliders[key].addEventListener('input', () => {
            document.getElementById(`val-${key}`).textContent = sliders[key].value;
        });
    });

    // Apply button
    document.getElementById('applyBtn').addEventListener('click', () => {
        config.terrainSize = parseInt(sliders.terrainSize.value);
        config.segments = parseInt(sliders.segments.value);
        config.heightScale = parseInt(sliders.heightScale.value);
        config.treeWidth = parseInt(sliders.treeWidth.value);
        config.stripeWidth = parseFloat(sliders.stripeWidth.value);
        config.crosshatchDensity = parseFloat(sliders.crosshatchDensity.value);
        config.ringSpacing = parseFloat(sliders.ringSpacing.value);

        createTerrain();

        // Update shader pattern uniforms
        if (terrainMaterial) {
            terrainMaterial.uniforms.stripeFreq.value = 2.0 * Math.PI / config.stripeWidth;
            terrainMaterial.uniforms.crosshatchFreq.value = 2.0 * Math.PI / config.crosshatchDensity;
            terrainMaterial.uniforms.ringFreq.value = 2.0 * Math.PI / config.ringSpacing;

            // Re-apply tee/hole positions after terrain recreation
            if (forestData) {
                const imgWidth = forestData.width;
                const imgHeight = forestData.height;
                if (forestData.tee) {
                    terrainMaterial.uniforms.teePos.value.set(
                        forestData.tee.x / imgWidth,
                        1.0 - (forestData.tee.y / imgHeight)
                    );
                }
                if (forestData.hole) {
                    terrainMaterial.uniforms.holePos.value.set(
                        forestData.hole.x / imgWidth,
                        1.0 - (forestData.hole.y / imgHeight)
                    );
                }
            }
        }

        rebuildTrees();
    });

    // Save button
    document.getElementById('saveBtn').addEventListener('click', async () => {
        if (!forestData) return;
        // Include config values in the saved data
        const dataToSave = {
            ...forestData,
            config: {
                terrainSize: config.terrainSize,
                segments: config.segments,
                heightScale: config.heightScale,
                treeWidth: config.treeWidth,
                stripeWidth: config.stripeWidth,
                crosshatchDensity: config.crosshatchDensity,
                ringSpacing: config.ringSpacing,
            }
        };
        const response = await fetch('/api/hole1/forest', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(dataToSave),
        });
        const result = await response.json();
        console.log('Save result:', result);
        alert('Forest data saved!');
    });

    // Load button
    document.getElementById('loadBtn').addEventListener('click', () => {
        loadForestData();
        alert('Forest data loaded!');
    });

    // Toggle with ~ key
    window.addEventListener('keydown', (e) => {
        if (e.key === '`' || e.key === '~') {
            configPanel.classList.toggle('visible');
        }
    });

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        // Cylindrical billboard: trees face camera on XZ plane, Y stays locked
        forestGroup.children.forEach(child => {
            if (child.userData.isTree) {
                const camXZ = new THREE.Vector3(
                    camera.position.x,
                    child.position.y,
                    camera.position.z
                );
                child.lookAt(camXZ);
            }
        });

        renderer.render(scene, camera);
    }
    animate();

    // --- RESIZE HANDLER ---
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
